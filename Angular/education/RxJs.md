<h1>RxJS</h1>

[//]:# (What is RxJS?)

<details>
    <summary>
        <b><big><big>
            What is RxJS?
        </big></big></b>
    </summary>

RxJS (Reactive Extensions for JavaScript) — это библиотека для реактивного программирования 
с использованием наблюдаемых объектов, которая упрощает создание асинхронного кода 
или кода на основе обратного вызова.

Используется зачастую для:
- Преобразование существующего кода для асинхронных операций с наблюдаемыми объектами
- Перебор значений в потоке
- Сопоставление значений различным типам
- Фильтрация потоков
- Составление нескольких потоков

</details>
<br>

[//]:# (What is Observable/Observer/Subject/Operator/Subscription?)

<details>
    <summary>
        <b><big><big>
            What is Observable/Observer/Subject/Operator/Subscription?
        </big></big></b>
    </summary>

**Наблюдаемый (Observable)**
Наблюдаемый объект — это функция, которая создает наблюдателя и прикрепляет его к источнику, 
где ожидаются значения, например клики, события мыши от элемента dom или HTTP-запрос и т. д.

**Наблюдатель (Observer)**
Это объект с методами next(), error() и complete(), который будет вызываться при взаимодействии 
с наблюдаемым, т.е. источник взаимодействует, например, нажатие кнопки, запрос Http и т. д. 
Проще говоря, наблюдаемый представляет асинхронный поток данных, 
и наблюдатель подписывается на наблюдаемое для получения потока.

**Подписка (Subscription)**
Когда наблюдаемое создается, для его выполнения нам нужно подписаться на него. 
Подписку можно использовать для отмены выполнения. 
Функция подписки запускает поток от наблюдаемого к функции наблюдателя.

**Subject**
Субъект — это наблюдаемое, которое может общаться со многими наблюдателями.

Используется для:
- вы можете подписаться на субъект, чтобы получать значения из его потока
- вы можете передать значения в поток, вызвав метод next()
- вы даже можете передать субъект в качестве наблюдателя в наблюдатель: 

**Operators**
Оператор — это чистая функция, которая принимает наблюдаемое в качестве входных данных,
а вывод также является наблюдаемым.

</details>
<br>

[//]:# (What is the difference between Hot & Cold Observable?)

<details>
    <summary>
        <b><big><big>
            What is the difference between Hot & Cold Observable?
        </big></big></b>
    </summary>

Холодные Observable не будут давать данные, пока мы не подпишемся.
Когда мы подписываемся на Observable, оно выполняет наблюдаемую функцию. 
**Поскольку код производителя включен в Observable функцию,
он запускается только при вызове наблюдаемой функции.**

**Холодные наблюдаемые являются одноадресной.** 
Каждая подписка выполняет наблюдаемую функцию и, следовательно, код для создания данных. 

**Горячие наблюдаемые излучают данные, которые были созданы вне тела наблюдаемой функции.**

Данные генерируются независимо от того, 
подписан ли наблюдатель на наблюдаемое или нет.
Наблюдаемая функция просто обращается к уже созданным данным (вне функции) 
и отправляет данные наблюдателям.

Все наблюдатели получат одни и те же данные. 
**Таким образом, говорят, что горячая наблюдаемая является многоадресной.**

</details>
<br>

[//]:# (What is the difference between Observble & Subject? What is Behaviour Subject?)

<details>
    <summary>
        <b><big><big>
            What is the difference between Observable & Subject? What is Behaviour Subject?
        </big></big></b>
    </summary>

**Субъект RxJS — это особый тип Observable, который позволяет передавать значения 
множеству наблюдателей.** 
**В то время как простые Observable являются одноадресными** 

**Используйте Observable, когда**
Обычный Observable следует использовать, когда вам нужен только один подписчик. 
Или вам все равно, что подписчик, который придет первым, будет завершен первым, 
пока второй не получит свои значения.

**Используйте Subject, когда**
Когда вам нужно несколько подписчиков и вы заботитесь о том, 
чтобы все подписчики одновременно получали свои новые значения, вам нужна тема.

- Используйте **BehaviourSubject**, когда вам нужно последнее заданное значение.
- Используйте **ReplaySubject**, когда вам нужно больше, чем последнее заданное значение. 
(Например, предыдущие пять значений)
- Используйте **AsyncSubject**, если вы хотите, чтобы подписчикам передавалось только 
последнее значение.

</details>
<br>

[//]:# (What is the difference between MergeMap, SwitchMap and ConcatMap?)

<details>
    <summary>
        <b><big><big>
            What is the difference between MergeMap, SwitchMap and ConcatMap?
        </big></big></b>
    </summary>

**switchMap , mergeMap , concatMap и ExhaustMap являются операторами выравнивания rxjs.**
Они считаются трансформационными операторами, поскольку они преобразуют
Observble после применения функции в новую Observble.

**mergeMap** - выполняет функцию, и одновременно следит за новыми вызовами,
когда он получает новый вызов, он начинает сразу же его обрабатывать, 
даже если текущий еще не выполнен, 
затем он отправляет обратно первое, что будет завершено и так далее.
(любая загрузка файлов)

**concatMap** - выполняет вызовы по порядку. 
Пока он выполняет функцию и приходит новый вызов, он принимает к сведению этот вызов (в буфере),
чтобы вернуться к нему после завершения текущей функции.
(отправка любых сообщений когда важен порядок)

**ExhaustMap** - Когда выполняется функция, будет игнорироваться любой другой вызов, 
пока не закончит текущий.
(проверка кредов, нас не интересует сколько раз пользователь нажмет, 
нас интересует только состояние на текущий момент)

**switchMap** - Когда выполняется функция и получает новый вызов, 
он бросает выполнение текущей функции и сразу начинает выполнять новую.
(Пользователь генерирует сложный хеш ключ, повторная отправка будет означать что старый уже не нужен)

</details>
<br>