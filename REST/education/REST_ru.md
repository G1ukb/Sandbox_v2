[//]: # (Rest)

<details>
    <summary>
        <b><big><big><big>
            Rest questions
        </big></big></big></b>
    </summary>

[//]: # (HTTP)
<br>
<details>
    <summary>
        <b><big><big>
            Что такое HTTP запрос и его структура
        </big></big></b>
    </summary>

HTTP - Трансферный протокол, который позволяет обмениваться данными в среде интернет 

Запрос
![img](https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/468/original/core_components_of_HTTP_Request.png?1622561120)

Ответ
![img](https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/467/original/core_components_of_HTTP_Response.png?1622561057)

</details>

[//]: # (Какие HTTP запросы бывают)
<br>
<details>
    <summary>
        <b><big><big>
            Какие HTTP запросы бывают
        </big></big></b>
    </summary>

* **GET**: используется для получения сведений с сервера и 
в основном является операцией только для чтения.
* **HEAD**: запрос get, но без тела (для извлечения метаинформации которая содержится в
заголовках ответа)
* **POST**: этот метод используется для создания новых ресурсов на сервере.
* **PUT**: этот метод используется для обновления старого/существующего 
ресурса на сервере или для замены ресурса.
* **DELETE**: этот метод используется для удаления ресурса на сервере.
* **PATCH**: используется для изменения ресурса на сервере.
* **OPTIONS**: Это извлекает список поддерживаемых опций ресурсов, 
присутствующих на сервере.

</details>

[//]: # (Rest)
<br>
<details>
    <summary>
        <b><big><big>
            Что такое Rest что такое RestFULL
        </big></big></b>
    </summary>

**Rest** - набор архитектурных правил соблюдая которые обеспечивается
максимально оптимальная разработка веб-сервисов.

REST - может использоваться практически для любого протокола,
при использовании для веб-API он обычно использует преимущества HTTP.

Одним из ключевых преимуществ API REST является то,
что он обеспечивает большую гибкость.

**RestFull** система - система которая реализуется все описанные правила

</details>

[//]: # (Минусы рест запросов)
<br>
<details>
    <summary>
        <b><big><big>
            Минусы рест запросов
        </big></big></b>
    </summary>

С точки зрения **клиентской** стороны, REST не хранит временного состояния 
из-за этого поведение временных переменных (хранение, безопасность, доступность)
полностью хранится на клиентской стороне.

С точки зрения **серверной** стороны, REST не накладывает ограничений безопасности
За обработку и безопасность данных которые передаются через REST
берет на себя сервер

</details> 

[//]: # (Правила Rest)
<br>
<details>
    <summary>
        <b><big><big>
            Правила Rest
        </big></big></b>
    </summary>

**1. Клиент-сервер**

Это ограничение основано на том, что клиент и сервер
должны быть отделены друг от друга и иметь возможность развиваться индивидуально.
Ui - как клиент

**2. Stateless (Отсутствие состояния)**

**Сервер не должен запоминать состояние** пользователя между запросами —
в каждом запросе передаётся информация, идентифицирующая пользователя
(например, token, полученный через OAuth-авторизацию)
и все параметры, необходимые для выполнения операции.

Независимость от состояния означает, что данные,
возвращаемые определенным вызовом API, не должны зависеть от вызовов, 
сделанных ранее.

Сделано это для мультизапросов, если сразу много пользователей обращаются к
системе трудозатратно запоминать состояние каждого из них.

**3. Кэширование**

**Ответ сервера может быть кэширован** на
определенный период времени и использоваться повторно без новых запросов к серверу.
(получение константных значений, таких как рабочие часовые пояса)

**4. Унифицированный интерфейс**

Все рест запросы должны быть построены с использованием общего шаблона
построения запросов. Для того чтобы каждый разработчик мог писать запросы
не применяя никаких правил из головы.

+ HATEOAS
  (Система, которая позволяет возвращать вместе с ответом рест запроса также и ссылки
  содержащие возможные рест запросы последующие за уже совершившимся.
  Таким образом мы усведомляем разработчика или пользователя о том каким рестом
  он может воспользоваться далее, и даем ему последнюю версию этого реста.
  Так же данные могут подставляться динамически)

+ самоОписываемость selfDescriptive
  (единый интерфейс между клиентами и серверами. Самоописательное сообщение содержит всю информацию, 
   необходимую получателю для его понимания. Не должно быть дополнительной информации в отдельной 
   документации или в другом сообщении.)


**5. Многоуровневая система**

Многоуровневое означает, что клиент не знает, является ли сервер,
который отвечает, на самом деле конечным сервером,
который обслуживает ресурс, что является отличным
принципом для обеспечения балансировки нагрузки и предоставления общих кэшей.

Нужно для масштабирования

**6. (Добавочное) удобство представления данных**
В качестве представления данных объекта передаются данные в формате JSON или XML

Рест должны отдавать единый формат ответа, для того чтобы обработчики были настроены
под что-то конкретное и не случалось исключений на этой почве.
</details>

[//]: # (SOAP против REST)
<br>
<details>
    <summary>
        <b><big><big>
            SOAP против REST
        </big></big></b>
    </summary>

Самое главное различие - логическое

**SOAP** - это протокол, который используется для реализации веб-сервисов

а **REST** - это набор архитектурных правил

Soap не может использовать REST, но REST может использовать SOAP

из минусов:
- SOAP только xml
- и не имеет возможности кешироваться
- работает медленнее
- не так просто тестировать как REST

из плюсов:
- SOAP используется когда нет возможности использовать рест 
  (требование обработать сценарии с состоянием)
- Поддержка устаревших систем, которые были сделаны до введения рест
- Предлагает большой уровень безопасности (как пример PayPal на soap)
- Предлагает транзакции

</details>

[//]: # (WEB-Socker против REST)
<br>
<details>
    <summary>
        <b><big><big>
            WEB-Socker против REST
        </big></big></b>
    </summary>

Разница в принципе обращения. 

Rest однонаправленный кидает реквест на сервер и тот присылает ответ

Web-Soket - многонаправленный, сокет кидает запрос на подключение,
потом подключается, потом общаются друг с другом, в конце закрывая конект

- веб сокеты подходят для прямого обращения, например игр
- у них нет разделения на url тело и хедеры, они сразу отправляют данные, следовательно быстрее
- сервер может задать вопрос клиенту, а не только клиент-серверу
- сохраняет состояние сеанса

из минусов:
- только вертикальное масштабирование
- зависят от IP адреса и номера порта
- требуется память для хранения данных

</details>

[//]: # (Что такое Payload)
<br>
<details>
    <summary>
        <b><big><big>
            Что такое Payload
        </big></big></b>
    </summary>

Payload - тело запроса которое несет необходимую информацию.
(обычно относят к POST запросам)

</details> 

[//]: # (JSON vs XML)
<br>
<details>
    <summary>
        <b><big><big>
            JSON vs XML
        </big></big></b>
    </summary>

Разница в логическом использовании. 

XML создавался как дескриптор, где теги и иерархия позволяют описать правила 

JSON создавался для передачи данных. И имеет более удобную структуру для
работы именно с передачей данных.

Это не значит что JSON нельзя использовать для описания, а XML для передачи данных,
но одно предпочтительней другому в разных ситуациях. (мы можем считать в уме, но 
пользуемся калькулятором)

</details>

[//]: # (Структура Rest URL)
<br>
<details>
    <summary>
        <b><big><big>
            Структура Rest URL
        </big></big></b>
    </summary>

общий структурный вид для запроса - /:entities[/:id][/?:params]
entity — название сущности, во множественном числе
id opt. — первичный ключ объекта. Если первичный ключ составной, то части указываются через слэш.
params opt. — дополнительные параметры выборки для списочных запросов

GET /:entities/:id    - get element by id
GET /:entities/       - get all elements
POST /:entities/      - add element
PUT /:entities/:id       - update element

- используйте существительные во множественном числе
- при использовании длинного имени используйте подчеркивание или дефис authorized-users
- только строчные буквы
- поддержка обратной совместимости
- использование http методов
- используйте значение как иерархию /users/{id}/address

</details>

[//]: # (Идемпотентный метод/Безопасный метод)
<br>
<details>
    <summary>
        <b><big><big>
            Идемпотентный метод/Безопасный метод
        </big></big></b>
    </summary>

Метод HTTP является идемпотентным, если повторный идентичный запрос,
сделанный один или несколько раз подряд, имеет один и тот же эффект,
не изменяющий состояние сервера.
Другими словами, идемпотентный метод не должен иметь никаких побочных эффектов (side-effects),
кроме сбора статистики или подобных операций.
Корректно реализованные методы GET, HEAD, PUT и DELETE идемпотентны,
но не метод POST.

Безопасные методы — это те, которые не изменяют внутренние ресурсы. 
Эти методы можно кэшировать и извлекать без какого-либо воздействия на ресурс.
(OPTIONS, GET, HEAD)

</details>

[//]: # (Параметры в ресте)
<br>
<details>
    <summary>
        <b><big><big>
            Параметры в ресте
        </big></big></b>
    </summary>

QUERY Parameters
Параметры QUERY появляются в URL после знака вопроса (?) После имени ресурса:
http://myserver.com/resource-name?param1=value1&param2=value2

PATH Parameters
{server_host}/students/{student_id}

HEADER Parameters
BODY Params

Лучшая практика для разработки RESTful API заключается в том, что параметры пути
используются для идентификации конкретного ресурса или ресурсов,
а параметры запроса используются для сортировки / фильтрации этих ресурсов.

</details>

[//]: # (Лучшие практики написания рестов)
<br>
<details>
    <summary>
        <b><big><big>
            Лучшие практики написания рестов
        </big></big></b>
    </summary>

- По возможности используйте JSON
- Используйте по возможности не более 3-4 уровней вложенности
- Множественное число
- В случае ошибки, REST должен возвращать не только статус но и описывающее предложение
- Если возвращается большой поток данных, по возможности применяйте фильтрацию
- Базовые принципы безопасности со стороны сервера
- Не забывать про кеширование
- Управление версиями апи, при этом не отключая старые версии, а используя пересылку

</details>

[//]: # (Как можно протестировать веб-службы RESTful?)
<br>
<details>
    <summary>
        <b><big><big>
            Как можно протестировать веб-службы RESTful?
        </big></big></b>
    </summary>

- Воспользоваться Postman. Где можно создавать сьюты тестовых данных и запускать их
- Воспользоваться Swagger.

</details>

[//]: # (Spring Rest)
<br>
<details>
    <summary>
        <b><big><big>
            Spring Rest
        </big></big></b>
    </summary>

Почему спринг рест
+ Это поддержка
+ Наличие полной документации
+ Огромной кол-во обсуждений и примеров реализаций

Минусы 
+ это фреймворк

Основные элементы
- @RestController помечает рест
- @GetMapping расставляется на методы
- @RequestParam - @HeaderParam

</details>

</details>
<br>
