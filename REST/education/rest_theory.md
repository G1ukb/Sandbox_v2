# HTTP

Для того чтобы разобраться с Rest для начала надо разобраться со структурой Http запроса
полкольку рест тесно работает с Http

Пример Запрос от браузера:

    GET / HTTP/1.1
    Host: webkyrs.info
    User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:18.0) Gecko/20100101 Firefox/18.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3
    Accept-Encoding: gzip, deflate
    Cookie: wp-settings
    Connection: keep-alive
 
Ответ: 
    
    HTTP/1.1 302 Moved Temporarily
    Server: nginx
    Date: Sat, 08 Mar 2014 22:29:53 GMT
    Content-Type: text/html
    Content-Length: 154
    Connection: keep-alive
    Keep-Alive: timeout=25
    Location: http://habrahabr.ru/users/alizar/
    
    <html>
    <head><title>302 Found</title></head>
    <body bgcolor="white">
    <center><h1>302 Found</h1></center>
    <hr><center>nginx</center>
    </body>
    </html>
    
Стартовая (начальная) строка запроса для HTTP 1.1 составляется по следующей схеме:
(Метод) (URI) (HTTP/Версия) (Пример: GET / HTTP/1.1)    

Reference-style: 
![alt text][logo]

[logo]: https://webkyrs.info/uploads/1574938179571-5ddfa64402c0f.png "Прослойка http запроса"

# Rest

Rest - передача состояния представления -
набор архитектурных правил соблюдая которые обеспечивается
максимально оптимальная разработка веб сервисов

REST - может использоваться практически для любого протокола, 
при использовании для веб-API он обычно использует преимущества HTTP.

Одним из ключевых преимуществ API REST является то,
что он обеспечивает большую гибкость.

Рест по правилам предоставляет контракт который состоит из 6 правил 

## **1. Клиент-сервер**

это ограничение основано на том, что клиент и сервер 
должны быть отделены друг от друга и иметь возможность развиваться индивидуально.
 ui - как клиент
 
## **2. Stateless (Отсутствие состояния)**

Сервер не должен запоминать состояние пользователя между запросами — 
в каждом запросе передаётся информация, идентифицирующая пользователя 
(например, token, полученный через OAuth-авторизацию) 
и все параметры, необходимые для выполнения операции.

Независимость от состояния означает, что данные, 
возвращаемые определенным вызовом API, не должны зависеть от вызовов, сделанных ранее.

## **3. Кэширование**

Ответ сервера может быть кэширован на 
определенный период времени и использоваться повторно без новых запросов к серверу.

## **4. Унифицированный интерфейс** 

К примеру для получения списка фильмов вы используете 
URL вида: /videos.com/movies, а для получения информации 
о конкретном фильме ваш URL будет: /videos.com/movies/1)

+ hateOas
+ самоОписываемость selfDescriptive

## **5. Многоуровневая система**

Многоуровневое означает, что клиент не знает, является ли сервер, 
который отвечает, на самом деле конечным сервером, 
который обслуживает ресурс, что является отличным 
принципом для обеспечения балансировки нагрузки и предоставления общих кэшей.

(5 серверов и сервер номер 3 может общаться только с сервером номер 2 и 4 
и в случае возникновения ошибки мы конкретно будем знать где искать, 
а пользователь получит унифицированный ответ)

## **6. (Добавочное) удобство представления данных**
В качестве представления данных объекта передаются данные в формате JSON или XML


Jersey (JAX-RS) Tutorials

Jakarta RESTful Web Services, (JAX-RS) - 
это спецификация API языка программирования Java, 
которая обеспечивает поддержку при создании веб-служб 
в соответствии с архитектурным шаблоном  (REST). 

JAX-RS использует аннотации, представленные в Java SE 5, 
для упрощения разработки и развертывания клиентов и конечных точек веб-служб.
Начиная с версии 1.1, JAX-RS является официальной частью Java EE 6.

JAX-RS предоставляет некоторые аннотации, помогающие сопоставить класс ресурса (POJO)
как веб-ресурс. В аннотациях используется пакет Java javax.ws.rs. Они включают:

@Path @GET @PUT @POST @DELETE @HEAD @Produces @Consumes 
@PathParam @QueryParam @MatrixParam @HeaderParam 
@CookieParam @FormParam @DefaultValue @Context

Собственно Jersey RESTful Web Services - это среда с открытым исходным кодом, 
для разработки RESTful Web Services на Java, которая обеспечивает поддержку API JAX-RS
и служит эталонной реализацией JAX-RS 

Jersey предоставляет собственный API, 
который расширяет инструментарий JAX-RS дополнительными функциями и утилитами 
для дальнейшего упрощения обслуживания RESTful и разработки клиентов.
           
           

# **JSON vs XML**
JSON - это как XML, потому что
- JSON, и XML являются удобочитаемыми
- JSON, и XML являются иерархическими
- JSON, и XML могут быть проанализированы и использованы многими языками программирования.
- JSON, и XML можно получить с помощью XMLHttpRequest

JSON отличается от XML, потому что
- JSON не использует конечный тег
- JSON короче
- JSON быстрее читать и писать
- JSON может использовать массивы

Почему JSON удобнее (личные наблюдения)
- JSON это изначально формат передали данных (т.е. он используется только для этого и это его целевая функция)
  В свою очередь XML это описательный формат нецелевым использованием которого является передача данных

- (CodeStyle) XML намного сложнее разобрать, чем JSON.
    
- (Обработка) JSON это готовый к использованию объект JavaScript.
   Т.е. JS не нужно что-то придумывать чтобы забирать поля и каким-то образом их использовать
   В свою очередь у джавы тоже практически не возникает проблем с обработкой JSON
   
Использование XML
- Получить документ XML
- Используйте XML DOM для циклического просмотра документа
- Извлекать значения и хранить в переменных

Использование JSON
- Получить строку JSON
- JSON.Parse строка JSON

## **JSON**

В JSON поддерживает следующие типы данных:
- примитивные типы данных
- объект
- массив (лист)
- значение NULL

Значения JSON не могут быть одним из следующих типов данных:
- функция
- дата
- undefined

## **Ограничения схемы JSON**

Библиотека Jackson предоставляет аннотации, которые вы можете использовать в POJO 
для управления сериализацией и десериализацией между POJO и JSON. 

- @JsonIgnore               - Игнорирование поля при ди/сериализации
- @JsonIgnoreProperties     - Чтобы указать несколько филдов для игнорирования
- @JsonIgnoreType           - Игнорирование класса во всех местах использования
- @JsonAutoDetect           - Ограничения видимости которые накладываютя 
на конструкторы или поля объекта с целью ограничения их видимости или наоборот
разрешения заполнять приматные поля без гетеров и сетеров

Сериализация (Backend -> Portman)
Дериализация (Portman -> Backend)

- @JsonValue                - Показывает String шаблок к которому будет приведен объект
                              после сериализации
- @JsonInclude              - Помогает не выводить поля которые не соответствуют условию (Null, Empty)
- @JsonPropertyOrder        - Указывает явный порядок полей при сериализации 
                              (поля нужно вводить руками {"поле1","поле2"})
- @JsonRawValue             - Автоматически убирает ковычки и икранирование у поля
- @JsonSerialize            - Использование кастомного сериализатора
- @JsonDeserialize          - Использование кастомного десериализатора
- @JsonRootName             - Используется для указания имени POJO, которое должно быть сериализовано.
                              Чтобы сериализация работала с @JsonRootName, 
                              необходимо включить SerializationFeature.WRAP_ROOT_VALUE.
                              Для десериализации должен быть включен DeserializationFeature.UNWRAP_ROOT_VALUE.
- @JsonGetter               - Устанавливает отображаемое имя поля вне зависимоти от имени в классе
- @JsonAnyGetter            - Описывает гетер мапы которая будет представлять JSON поля в формате <ИмяПоля, Значение>
- @JsonSetter               - Работает так же как и JsonGetter и JsonProperty
- @JsonAnySetter            - Работает так же как @JsonAnyGetter
- @JacksonInject            - Используется, чтобы сообщить Джексону, что конкретные значения 
                              десериализованного объекта будут введены, а не прочитаны из строки JSON
- @JsonFormat               - используется, чтобы сообщить что формат, в котором значение для поля сериализуется. 
                              Он определяет формат, используя перечисление JsonFormat.Shape.
                              
                              
## Валидация JSON XML на уровне схемы

Для того чтобы отвалидировать полученную схему существуют схемовые валидаторы JSON и XML
Примеры представлены в файлах JSON_validation_shema.json XML_validation_shema.xml

При этом Js изначально умеет валидировать JSON схемы при помощи команды 

schema.validate(names[i]).errors; - при этом было указано 
что большой поток данных будет провалидирован за короткий промежуток времени

    для Java Spring предлагает библиотеку FastJSON:
    Schema schema = SchemaLoader.load(jsonSchema);
    schema.validate(jsonSubject);

Для XML существует XSD схема
И в коде Java проверяется с помощью дефолтных библиотек Java
а именно javax.xml.

    SchemaFactory generativePatterns.factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
    Schema schema = generativePatterns.factory.newSchema(new File(xsdPath));
    Validator validator = schema.newValidator();
    validator.validate(new StreamSource(new File(xmlPath)));
    
В рамках js xml валидиться через дом парсер и это не совсем удобно  

# Структура Rest URL

общий структурный вид для запроса - /:entity[/:id][/?:params]
entity — название сущности, например, класса или таблицы/представления в БД. Примеры: users, dictionary
id opt. — первичный ключ объекта. Если первичный ключ составной, то части указываются через слэш.
params opt. — дополнительные параметры выборки для списочных запросов

GET /:entity/:id    - get element by id
GET /:entity/       - get all elements
POST /:entity/      - add element
PUT /:entity/       - update element

# Идемпотентный метод

Метод HTTP является идемпотентным, если повторный идентичный запрос, 
сделанный один или несколько раз подряд, имеет один и тот же эффект, 
не изменяющий состояние сервера. 
Другими словами, идемпотентный метод не должен иметь никаких побочных эффектов (side-effects),
кроме сбора статистики или подобных операций. 
Корректно реализованные методы GET, HEAD, PUT и DELETE идемпотентны, 
но не метод POST.

# Параметры в ресте

QUERY Parameters
Параметры QUERY появляются в URL после знака вопроса (?) После имени ресурса:
http://myserver.com/resource-name?param1=value1&param2=value2

PATH Parameters
{server_host}/students/{student_id}

HEADER Parameters
BODY Params

Лучшая практика для разработки RESTful API заключается в том, что параметры пути 
используются для идентификации конкретного ресурса или ресурсов, 
а параметры запроса используются для сортировки / фильтрации этих ресурсов.