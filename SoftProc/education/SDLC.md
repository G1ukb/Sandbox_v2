<h1>SDLC</h1> 
<h4> 

[Back to menu](..%2FMenu.md)

</h4>

[//]: # (What is the action plan in case of a production Java error?)
<br>
<details>
    <summary style="font-size: 25px;">
        <b>
            What is the action plan in case of a production Java error?
        </b>
    </summary>
<br>

Error Identification: (checking the error logs, monitoring systems,
or user reports)
Replicate the Error: (understand the conditions under which the error occurs)
Analyze the Error: to understand what is causing the error
Research: Deep investigation
Fix the Error:
Test:
Deploy:
Document:
Agile Retro, what we can do not to have this problem in future

</details>

////////////////////////////


[//]: # (Что такое Software development process)
<br>
<details>
    <summary style="font-size: 25px;">
        <b>
            Что такое Software development process
        </b>
    </summary>
<br>

Процесс разработки программного обеспечения,
или жизненный цикл разработки программного обеспечения (SDLC),
это последовательность шагов, выполняемых во время разработки программного обеспечения.

Отсутствие плана разработки программного обеспечения
означает более длительные сроки, низкое качество или даже полный провал.
Хуже того, ваши разработчики не знают, что им делать.
В то время как ваши менеджеры проектов не будут иметь ни малейшего представления о том,
какой прогресс был достигнут, и есть ли у вас бюджет или даже на пути к его завершению!

использование SDLC имеет ряд других преимуществ:

- Создает общий набор фраз для каждого шага
  (тут как с паттернами, гораздо проще сказать слово которое все знают,
  нежели каждый раз разжевывать, что оно делает)

- Определяет каналы связи и ожидания между разработчиками и участниками проекта

- Устанавливает четкие роли и обязанности для всей вашей команды
  (разработчиков, дизайнеров, менеджеров проектов и т. Д.)

- Предоставляет «definition of done» для каждого шага,
  чтобы остановить сползание объема работ и помочь продолжить реализацию проекта.

- Формализует, как работать с багами, добавлять или обновления функционал

</details>

[//]: # (Шаги SDLC)
<br>
<details>
    <summary style="font-size: 25px;">
        <b>
            Шаги SDLC
        </b>
    </summary>
<br>

**1. Анализ и планирование**

Первым шагом SDLC является планирование. Обычно это означает изучение:
- Согласованность: как этот проект связан с более крупной миссией и целями вашей компании?
- Доступность и распределение ресурсов: есть ли у вас люди и инструменты, чтобы взяться за это?
- Планирование проекта: как этот проект соответствует целям и другим задачам вашей компании?
- Оценка стоимости: сколько это будет стоить?

В конце этапа планирования у вас должно быть достаточно информации,
чтобы составить высокоуровневый объем работ (ScopeOfWork) - план,
в котором подробно описывается, что создается, почему и как вы это видите.

**2. Требования**

**Цель этапа** - понять технические требования проекта.
Каждая часть программного обеспечения - будь то приложение,
редизайн веб-сайта или новая функция - должна решать проблему клиента.

На этом этапе SOW продолжает заполняться
и начинают задавайте вопросы о специфике этого проекта, например:

- Какую проблему это решает?
- Кто будет его использовать и зачем?
- Какой нужен ввод / вывод данных?
- Потребуется ли вам интегрироваться с другими инструментами или API?
- Как вы будете обеспечивать безопасность / конфиденциальность?

Как только ваша команда разработчиков получит ответы на эти вопросы,
они смогут приступить к определению технических требований,
условий тестирования и принять решение о стеке технологий.

**3. Дизайн и прототипирование**

При наличии требований пора приступить к разработке того,
как это программное обеспечение будет выглядеть и как оно будет работать.

**Цель этапа** - проверить идеи и получить ценные отзывы,
прежде чем вы закрепите свои идеи в коде.

**4. Разработка программного обеспечения**

После того как дизайны и требования обговорены, самое время создать его.

Этот этап, очевидно, является самым сложным и потенциально самым рискованным
этапом SDLC.
**Цель здесь** - придерживаться SOW, избегать сползания рабочего процесса
и создавать чистое, эффективное программное обеспечение

**5. Тестирование**

Поскольку ваша команда разрабатывает программное обеспечение,
вы будете одновременно тестировать, отслеживать и исправлять ошибки.
Однако после того, как функции будут реализованы
и продукт будет признан готовым к использованию,
вам потребуется провести еще один раунд более глубокого тестирования.
Это может означать выпуск продукта для небольшой группы бета-тестеров
или использование инструментов UX для отслеживания того,
как пользователи взаимодействуют с ним.

**Цель этапа** - убедиться, что вы не доставляете программное обеспечение
с ошибками реальным клиентам.

**6. Развертывание**

Когда тяжелая работа (и кодирование) закончилась,
самое время запустить ваше программное обеспечение для всех ваших пользователей.
**цель этапа** - запуск вашего кода в производство.

**7. Обслуживание и обновления**

Требования и потребности клиентов постоянно развиваются.
И когда люди начнут использовать ваше программное обеспечение,
они, несомненно, будут находить ошибки,
запрашивать новые функции и запрашивать дополнительные или другие функции.

Все эти запросы необходимо направить обратно в бэклог,
чтобы им можно было определить приоритеты и включить их в дорожную карту продукта.

</details>

[//]: # (Лучшие практики SDP)
<br>
<details>
    <summary style="font-size: 25px;">
        <b>
            Лучшие практики SDP
        </b>
    </summary>
<br>

**Waterfall**

Вся разработка делится на фазы. Эти фазы четко определены и описаны сразу.
Такой подход подходит для государственных организаций, которые заранее нуждаются
в подписях на всех этапах проектирования.

+ Полное документирование каждого этапа;
+ Четкое планирование сроков и затрат;
+ Прозрачность процессов для заказчика;

- Необходимость утверждения полного объема требований
- В случае необходимости внесения изменений требований позднее –
  возврат к первой стадии и переделка заново всей проделанной работы;
- Увеличение затрат средств и времени в случае необходимости изменения требований.

![](https://plan.io/images/blog/waterfall-process.png?1598254777)

**Agile и Scrum**

Суть Agile заключается в частых выпусках части проекта
и реагировании на потребности пользователей или заказчика,
даже если это идет вразрез с вашими первоначальными планами.

+ гибкая, адаптивная методика.
  Вы в любой момент сможете сделать изменения в продукте
+ Выполняя основную работу можно запустить проект быстро с минимальным функционалом.
+ В Скраме делается упор на команду, которая
  решает поставленные задачи с минимальным контролем со стороны начальства.

- Неопределенность. Кол-во спринтов может быть неограничено, потому не понятно,
  когда закончится проект
- В скрам. Работа делается на команду, самостоятельно командой. Потому следует
  четко относиться к рабочему составу.

![](https://plan.io/images/blog/agile-scrum-process.png?1598254777)

**Incremental and Iterative**

Итеративная разработка:
Выполнение работ параллельно с анализом полученных результатов
и корректировкой предыдущих этапов работы.
Проект при этом подходе в каждой фазе развития проходит повторяющийся цикл PDCA:
Планирование — Реализация — Проверка — Оценка

+ раннее создание работающего ПО;
+ готовность к изменению требований на любом этапе разработки;
+ каждая итерация маленькая из-за чего, тестирование и анализ рисков обеспечить проще,
  чем для всего жизненного цикла продукта.

- могут возникнуть проблемы с реализацией общей архитектуры системы,
  поскольку не все требования известны к началу проектирования.

![](https://plan.io/images/blog/iterative-process.png?1598254777)

Итерационная разработка - это разработка небольшими шагами,
в ходе которых анализируются полученные промежуточные результаты,
устанавливаются новые требования и корректируются предыдущие этапы работы.

Каждая из итераций включает в себя все процессы SDLC.
Однако в рамках одной итерации разрабатывается только
отдельный компонент или версия, а не весь проект.

Следующая итерация приводит либо к новой функциональности,
либо к улучшенной существующей функциональности продукта.

![](https://plan.io/images/blog/incremental-process.png?1598254777)

+ Быстрый запуск проекта. Вы начинаете свой проект в более короткие сроки
+ Сокращение рисков. Проблемы выявляются и решаются во время итераций.
+ Гибкость в модификации.
+ Регулярный выпуск новых версий.
+ Оперативная обратная связь.

- Нет фиксированного бюджета или сроков.
- Сильное вовлечение клиентов в процесс.
- Возможные проблемы с архитектурой.

**V-Shaped**

Каждый этап V-образного процесса сопровождается строгим этапом
«валидации и верификации», на котором требования проверяются
перед тем, как двигаться дальше.

+ планирование и разработка тестов, происходят задолго до написания кода
+ дефекты обнаруживаются на ранней стадии

- Очень жесткий и наименее гибкий.
-  Если какие-либо изменения происходят на полпути, то V начинается заново

![](https://plan.io/images/blog/v-shaped-process.png?1598254777)

**Spiral**

Спиральная модель - это комбинация модели водопада и итеративной модели.
Каждый этап спиральной модели начинается с определения цели проектирования
и заканчивается тем, что клиент просматривает прогресс.

Команда разработчиков модели Spiral начинает с небольшого набора требований
и проходит каждую фазу разработки для этого набора требований,
пока приложение не будет готово к стадии производства.

+ Дополнительные функции или изменения могут быть внесены на более позднем этапе
+ Оценка стоимости упрощается, так как создание прототипа выполняется небольшими фрагментами.
+ Помогает в управлении рисками
+ Всегда есть отзывы клиентов

- Риск несоблюдения графика или бюджета
- Необходимо строго соблюдать протокол спиральной модели.

![](https://plan.io/images/blog/spiral-process.png?1598254777)


</details>

[//]: # (Code review)
<br>
<details>
    <summary style="font-size: 25px;">
        <b>
            Code review
        </b>
    </summary>
<br>

Проверка кода - это деятельность по обеспечению качества кода,
при которой один или несколько человек проверяют код путем
просмотра и чтения его частей,
делают это после реализации или в качестве прерывания реализации.
Лица, проводящие проверку, за исключением автора, называются «рецензентами»

Ревью делается для:
- Улучшения качества кода
- Обнаружение дефектов
- Обучение / передача знаний
- Повышение чувства взаимной ответственности (кодекс солидарности)
- Поиск лучших решений

</details>

[//]: # (Эстимации)
<br>
<details>
    <summary style="font-size: 25px;">
        <b>
            Эстимации
        </b>
    </summary>
<br>

**Оценка определяет**, сколько денег, усилий, ресурсов и времени
потребуется для создания/реализации конкретной задачи.

**Стори поинтами** измеряют усилия, которые нужны,
чтобы выполнить отрезок работы. Пользуясь стори поинтами, 9
мы присваиваем каждому элементу (работы) некое количественное значение.
Сами по себе эти количественные оценки не важны.
Важно то, как оценки разных элементов соотносятся друг с другом.

Измеряя работу стори поинтами, обязательно оцените каждый из этих факторов:
- Объем работы для выполнения.
- Сложность работы.
- Риски или неопределенность при выполнении работы.

</details>

[//]: # (Виды эстимации задач)
<br>
<details>
    <summary style="font-size: 25px;">
        <b>
            Виды эстимации задач
        </b>
    </summary>
<br>

**T-Shirt Sizes (Размеры футболки)**

В качестве единицы измерения в этой технике используется
размер футболки: XS, S, M, L, XL.
Команда принимает решение о размере той или иной пользовательской
истории в ходе совместной открытой дискуссии.

Cамые мелкие задачи принимаются за XS .
После этого остальные задачи оцениваются с точки зрения
насколько они больше XS.

**Planning Poker (Покера планирования)**

Это одна из самых популярных техник оценки.
Участники процесса используют специально пронумерованные карты,
чтобы голосовать с их помощью за оценку задач.
Обычно для «покера» используются карты с числами Фибоначчи, но возможны и другие варианты.
Процесс оценки выглядит следующим образом:

- Каждый участник получает колоду карт с числовыми значениями для оценки.
- Кто-то делает краткий анонс очередной пользовательской истории и отвечает
  на вопросы команды по данной задаче.
- Участники «покера» выбирают карту с подходящей по их мнению оценкой
  и кладут их рубашкой вверх (чтобы не влиять на выбор друг друга).
- После того, как все члены команды выбрали свои оценки карты одновременно переворачиваются.
- Участникам с самыми низкими и высокими оценками делают краткие комментарии
  объясняя свой выбор оценки.
- В итоге процесса обсуждения команда приходит к единому решению и после этого переходит
  к следующей пользовательской истории.

**Bucket System (Система "ведерок")**

- Выберите случайным образом задачу из списка задач.
  Поместите его в ведро «?». Это наш первый справочный элемент.
- Таким же способом определить следующие 2 задачи
- После этого определен приблизительный вес задач и можно определить
  сложность оставшихся в соотношении с первыми 3мя
- Раздайте все оставшиеся предметы поровну всем участникам.
  Каждый участник ставит предметы на весы без обсуждения с другими участниками.
  Если у человека есть предмет, который он действительно не понимает,
  то этот предмет можно предложить кому-то другому.
- Все спокойно просматривают предметы в ведерках.
- Если участник находит неуместную эстимацию, он может поднят дискус с группой.
  Затем группа обсуждает его до тех пор, пока не будет достигнут консенсус.

**Dot-voting (Голосование по точкам)**

- Все оцениваемые задачи размещаются на столе\доске.
- Для выполнения оценки каждый из участников получает одинаковое количество «точек».
- Каждый член команды распределяет свои «точки» между задачами как он считает нужным,
  учитываю, что чем больше «точек», тем сложнее задача и тем больше на нее необходимо времени.
- После того как каждый участник сделал свою оценку и распределил все свои «точки»,
  подсчитывается общее количество точек выставленных для каждой пользовательской истории.
  В результате все задачи ранжируются между собой по количеству «точек».

**Maximum Size or Less (Разделение до максимального размера или меньше)**

- Вначале определяют максимально возможный размер для задачи
- Каждая история обсуждается всеми участниками, чтобы ответить на вопрос:
  оцениваемая задача больше максимального значения или меньше\равна ему?
- Если данная история больше максимального размера, то группа декомпозирует ее
  на подзадачи и повторяет процесс.
- Процесс продолжается пока все оцениваемые задачи не окажутся
  в разрешенном диапазоне размеров – будут равны или будут меньше
  выбранного за максимальное значения.

**Big/Small/Uncertain (Большой/Малый/Неопределенный)**

Данный метод похож на технику Bucket System, только используется 3 ведра:
большой размер, малый размер, неопределенный размер задачи.

- Все истории обсуждаются участниками и помещаются в одну из трех категорий.
- Сначала группа проводит групповое обсуждение нескольких первых задач (3-5),
  определяя масштаб и ориентиры для каждой категории.
- Затем, подобно Bucket System, оставшиеся истории распределяются между участниками
  и оцениваются самостоятельно, что сильно ускоряет процесс.

**Ordering Rule (Выстраивание порядка)**

- Сначала все оцениваемые истории выписываются на карточки.
- Карточки с задачами случайным образом размещаются на столе или доске со шкалой,
  на границах которой указаны «малый размер» и «большой размер».
- Каждый участник по очереди совершает свой «ход» оценки.
  Такой «ход» включает одно из следующих возможных действий:
  переместить любую историю по шкале на одно деление,
  обсудить историю с коллегами,
  пропустить свой «ход».
- В результате «ходов» сотрудников задачи могут перемещаться по доске,
  их оценка друг относительно друга уточняется.
- Когда все участники пропускают свой «ход», процесс оценки завершается.
  Все задачи распределены по шкале между значениями «малый размер» и «большой размер».


</details>

[//]: # (Стратегии ветвления)
<br>
<details>
    <summary style="font-size: 25px;">
        <b>
            Стратегии ветвления
        </b>
    </summary>
<br>

- Branching strategy описывает общие сценарии создания новых веток и связанные с ними необходимые действия.

Задачи:
- Разрешить параллельное развитие отдельных функций;
- Изолируйте изменения, не принятые изменения от кодовой базы;

![](https://elearn.epam.com/assets/courseware/v1/5298ff738434f41a954622922f539b9d/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/Branching_strategy_Branching.png)

- **ОДНОВЕТОЧНОЕ РАЗВИТИЕ** ветвления на основе магистрали нацелена
  на поддержание одной ветки разработки в работоспособном состоянии.
  Это сводит к минимуму количество других используемых ветвей,
  так как все разработчики фиксируются в одной общей ветке под контролем версий.

Ветка создается для выпуска, но только инженеры по выпуску могут работать в ветвях выпуска.
Они также могут выбирать отдельные коммиты из основной ветки в ветку выпуска.

Но ошибочный фикс почти мгновенно влияет на других разработчиков.

**По способу интеграции**
- Интеграция в общую магистраль
- Незавершенные функции в основной кодовой базе
- Небольшие, но частые слияния
- Высокая стоимость незавершенных работ

![](https://elearn.epam.com/assets/courseware/v1/9bdef8665c6aee2d14bb4f8c32ee10b2/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/Branching_strategy_single_branch.png)

- **СТРАТЕГИЯ ФУНКЦИОНАЛЬНЫХ ВЕТОК**

В центральном репозитории находится ветвь разработки,
в которой исходный код отражает состояние с последними внесенными изменениями.
Ветки функций используются для разработки новых функций.
Когда начинается разработка функции, целевая версия может быть неизвестна.
Суть функциональной ветки заключается в том, что она существует, пока функция находится в разработке.

Релиз в таких ветках - Ветви выпуска создаются из веток разработки.
Эти ветви могут существовать какое-то время, пока релиз не будет окончательно развернут.
В течение этого времени в этой ветке могут быть исправлены ошибки.
Добавлять сюда большие новые функции категорически запрещено.
Их нужно объединить в разработку, а значит, ждать следующего большого релиза.

**По способу интеграции**
- Отложенная интеграция, интегрировать функцию убедившись в ее завершении
- Изолируйте недоработанные функции
- Выберите функции для выпуска в случае интеграции
- Множество веток

- **Альтернатива GIT FLOW - GITHUB FLOW**
  В ответ на Git flow была описана более простая альтернатива, названная GitHub flow.
  Этот поток имеет только функциональные ветви и главную ветвь.
  Все, что находится в основной ветке, можно развернуть,
  поэтому для работы над чем-то новым создайте функцтональную ветку.
  Когда код будет готов, вы создаете запрос на слияние или вытягивание.

![](https://elearn.epam.com/assets/courseware/v1/55ccd11743fa796fe3769892b8729c8b/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/GitHub_flow.svg)

- **Альтернатива GIT FLOW - GITLUB FLOW**

GitLab предлагает создать ветки staging and production.
Когда кто-то хочет развернуть код на промежуточной стадии,
он создает запрос на слияние из основной ветки в предварительную.
А запуск кода происходит путем слияния промежуточной ветви с производственной.
Этот процесс гарантирует, что все было протестировано во всех средах

![](https://elearn.epam.com/assets/courseware/v1/29f33aa887951a29536c27e09a958b3c/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/GitLab_flow.svg)

</details>