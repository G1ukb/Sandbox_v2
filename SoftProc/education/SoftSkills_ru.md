[//]: # (SOFT skills)

<details>
    <summary>
        <b><big><big><big>
            SOFT skills
        </big></big></big></b>
    </summary>

[//]: # (Software development process)
<br>
<details>
    <summary>
        <b><big><big><big>
            Software development process
        </big></big></big></b>
    </summary>

[//]: # (Что такое Software development process)
<br>
<details>
    <summary>
        <b><big><big><big>
            Что такое Software development process
        </big></big></big></b>
    </summary>

Процесс разработки программного обеспечения,
или жизненный цикл разработки программного обеспечения (SDLC),
это последовательность шагов, выполняемых во время разработки программного обеспечения.

Отсутствие плана разработки программного обеспечения
означает более длительные сроки, низкое качество или даже полный провал.
Хуже того, ваши разработчики не знают, что им делать.
В то время как ваши менеджеры проектов не будут иметь ни малейшего представления о том,
какой прогресс был достигнут, и есть ли у вас бюджет или даже на пути к его завершению!

использование SDLC имеет ряд других преимуществ:

- Создает общий набор фраз для каждого шага
  (тут как с паттернами, гораздо проще сказать слово которое все знают,
  нежели каждый раз разжевывать, что оно делает)

- Определяет каналы связи и ожидания между разработчиками и участниками проекта

- Устанавливает четкие роли и обязанности для всей вашей команды
  (разработчиков, дизайнеров, менеджеров проектов и т. Д.)

- Предоставляет «definition of done» для каждого шага,
  чтобы остановить сползание объема работ и помочь продолжить реализацию проекта.

- Формализует, как работать с багами, добавлять или обновления функционал

</details>

[//]: # (Шаги SDLC)
<br>
<details>
    <summary>
        <b><big><big><big>
            Шаги SDLC
        </big></big></big></b>
    </summary>

**1. Анализ и планирование**

Первым шагом SDLC является планирование. Обычно это означает изучение:
- Согласованность: как этот проект связан с более крупной миссией и целями вашей компании?
- Доступность и распределение ресурсов: есть ли у вас люди и инструменты, чтобы взяться за это?
- Планирование проекта: как этот проект соответствует целям и другим задачам вашей компании?
- Оценка стоимости: сколько это будет стоить?

В конце этапа планирования у вас должно быть достаточно информации,
чтобы составить высокоуровневый объем работ (ScopeOfWork) - план,
в котором подробно описывается, что создается, почему и как вы это видите.

**2. Требования**

**Цель этапа** - понять технические требования проекта.
Каждая часть программного обеспечения - будь то приложение,
редизайн веб-сайта или новая функция - должна решать проблему клиента.

На этом этапе SOW продолжает заполняться
и начинают задавайте вопросы о специфике этого проекта, например:

- Какую проблему это решает?
- Кто будет его использовать и зачем?
- Какой нужен ввод / вывод данных?
- Потребуется ли вам интегрироваться с другими инструментами или API?
- Как вы будете обеспечивать безопасность / конфиденциальность?

Как только ваша команда разработчиков получит ответы на эти вопросы,
они смогут приступить к определению технических требований,
условий тестирования и принять решение о стеке технологий.

**3. Дизайн и прототипирование**

При наличии требований пора приступить к разработке того,
как это программное обеспечение будет выглядеть и как оно будет работать.

**Цель этапа** - проверить идеи и получить ценные отзывы,
прежде чем вы закрепите свои идеи в коде.

**4. Разработка программного обеспечения**

После того как дизайны и требования обговорены, самое время создать его.

Этот этап, очевидно, является самым сложным и потенциально самым рискованным
этапом SDLC.
**Цель здесь** - придерживаться SOW, избегать сползания рабочего процесса
и создавать чистое, эффективное программное обеспечение

**5. Тестирование**

Поскольку ваша команда разрабатывает программное обеспечение,
вы будете одновременно тестировать, отслеживать и исправлять ошибки.
Однако после того, как функции будут реализованы
и продукт будет признан готовым к использованию,
вам потребуется провести еще один раунд более глубокого тестирования.
Это может означать выпуск продукта для небольшой группы бета-тестеров
или использование инструментов UX для отслеживания того,
как пользователи взаимодействуют с ним.

**Цель этапа** - убедиться, что вы не доставляете программное обеспечение
с ошибками реальным клиентам.

**6. Развертывание**

Когда тяжелая работа (и кодирование) закончилась,
самое время запустить ваше программное обеспечение для всех ваших пользователей.
**цель этапа** - запуск вашего кода в производство.

**7. Обслуживание и обновления**

Требования и потребности клиентов постоянно развиваются.
И когда люди начнут использовать ваше программное обеспечение,
они, несомненно, будут находить ошибки,
запрашивать новые функции и запрашивать дополнительные или другие функции.

Все эти запросы необходимо направить обратно в бэклог,
чтобы им можно было определить приоритеты и включить их в дорожную карту продукта.

</details>

[//]: # (Лучшие практики SDP)
<br>
<details>
    <summary>
        <b><big><big><big>
            Лучшие практики SDP
        </big></big></big></b>
    </summary>

**Waterfall**

Вся разработка делится на фазы. Эти фазы четко определены и описаны сразу.
Такой подход подходит для государственных организаций, которые заранее нуждаются
в подписях на всех этапах проектирования.

+ Полное документирование каждого этапа;
+ Четкое планирование сроков и затрат;
+ Прозрачность процессов для заказчика;

- Необходимость утверждения полного объема требований
- В случае необходимости внесения изменений требований позднее –
  возврат к первой стадии и переделка заново всей проделанной работы;
- Увеличение затрат средств и времени в случае необходимости изменения требований.

![](https://plan.io/images/blog/waterfall-process.png?1598254777)

**Agile и Scrum**

Суть Agile заключается в частых выпусках части проекта
и реагировании на потребности пользователей или заказчика,
даже если это идет вразрез с вашими первоначальными планами.

+ гибкая, адаптивная методика.
  Вы в любой момент сможете сделать изменения в продукте
+ Выполняя основную работу можно запустить проект быстро с минимальным функционалом.
+ В Скраме делается упор на команду, которая
  решает поставленные задачи с минимальным контролем со стороны начальства.

- Неопределенность. Кол-во спринтов может быть неограничено, потому не понятно,
  когда закончится проект
- В скрам. Работа делается на команду, самостоятельно командой. Потому следует
  четко относиться к рабочему составу.

![](https://plan.io/images/blog/agile-scrum-process.png?1598254777)

**Incremental and Iterative**

Итеративная разработка:
Выполнение работ параллельно с анализом полученных результатов
и корректировкой предыдущих этапов работы.
Проект при этом подходе в каждой фазе развития проходит повторяющийся цикл PDCA:
Планирование — Реализация — Проверка — Оценка

+ раннее создание работающего ПО;
+ готовность к изменению требований на любом этапе разработки;
+ каждая итерация маленькая из-за чего, тестирование и анализ рисков обеспечить проще,
  чем для всего жизненного цикла продукта.

- могут возникнуть проблемы с реализацией общей архитектуры системы,
  поскольку не все требования известны к началу проектирования.

![](https://plan.io/images/blog/iterative-process.png?1598254777)

Итерационная разработка - это разработка небольшими шагами,
в ходе которых анализируются полученные промежуточные результаты,
устанавливаются новые требования и корректируются предыдущие этапы работы.

Каждая из итераций включает в себя все процессы SDLC.
Однако в рамках одной итерации разрабатывается только
отдельный компонент или версия, а не весь проект.

Следующая итерация приводит либо к новой функциональности,
либо к улучшенной существующей функциональности продукта.

![](https://plan.io/images/blog/incremental-process.png?1598254777)

+ Быстрый запуск проекта. Вы начинаете свой проект в более короткие сроки
+ Сокращение рисков. Проблемы выявляются и решаются во время итераций.
+ Гибкость в модификации.
+ Регулярный выпуск новых версий.
+ Оперативная обратная связь.

- Нет фиксированного бюджета или сроков.
- Сильное вовлечение клиентов в процесс.
- Возможные проблемы с архитектурой.

**V-Shaped**

Каждый этап V-образного процесса сопровождается строгим этапом
«валидации и верификации», на котором требования проверяются
перед тем, как двигаться дальше.

+ планирование и разработка тестов, происходят задолго до написания кода
+ дефекты обнаруживаются на ранней стадии

- Очень жесткий и наименее гибкий.
-  Если какие-либо изменения происходят на полпути, то V начинается заново

![](https://plan.io/images/blog/v-shaped-process.png?1598254777)

**Spiral**

Спиральная модель - это комбинация модели водопада и итеративной модели.
Каждый этап спиральной модели начинается с определения цели проектирования
и заканчивается тем, что клиент просматривает прогресс.

Команда разработчиков модели Spiral начинает с небольшого набора требований
и проходит каждую фазу разработки для этого набора требований,
пока приложение не будет готово к стадии производства.

+ Дополнительные функции или изменения могут быть внесены на более позднем этапе
+ Оценка стоимости упрощается, так как создание прототипа выполняется небольшими фрагментами.
+ Помогает в управлении рисками
+ Всегда есть отзывы клиентов

- Риск несоблюдения графика или бюджета
- Необходимо строго соблюдать протокол спиральной модели.

![](https://plan.io/images/blog/spiral-process.png?1598254777)


</details>

[//]: # (Code review)
<br>
<details>
    <summary>
        <b><big><big><big>
            Code review
        </big></big></big></b>
    </summary>

Проверка кода - это деятельность по обеспечению качества кода,
при которой один или несколько человек проверяют код путем
просмотра и чтения его частей,
делают это после реализации или в качестве прерывания реализации.
Лица, проводящие проверку, за исключением автора, называются «рецензентами»

Ревью делается для:
- Улучшения качества кода
- Обнаружение дефектов
- Обучение / передача знаний
- Повышение чувства взаимной ответственности (кодекс солидарности)
- Поиск лучших решений

</details>

[//]: # (Эстимации)
<br>
<details>
    <summary>
        <b><big><big><big>
            Эстимации
        </big></big></big></b>
    </summary>

**Оценка определяет**, сколько денег, усилий, ресурсов и времени
потребуется для создания/реализации конкретной задачи.

**Стори поинтами** измеряют усилия, которые нужны,
чтобы выполнить отрезок работы. Пользуясь стори поинтами, 9
мы присваиваем каждому элементу (работы) некое количественное значение.
Сами по себе эти количественные оценки не важны.
Важно то, как оценки разных элементов соотносятся друг с другом.

Измеряя работу стори поинтами, обязательно оцените каждый из этих факторов:
- Объем работы для выполнения.
- Сложность работы.
- Риски или неопределенность при выполнении работы.

</details>

[//]: # (Виды эстимации задач)
<br>
<details>
    <summary>
        <b><big><big><big>
            Виды эстимации задач
        </big></big></big></b>
    </summary>

**T-Shirt Sizes (Размеры футболки)**

В качестве единицы измерения в этой технике используется
размер футболки: XS, S, M, L, XL.
Команда принимает решение о размере той или иной пользовательской
истории в ходе совместной открытой дискуссии.

Cамые мелкие задачи принимаются за XS .
После этого остальные задачи оцениваются с точки зрения
насколько они больше XS.

**Planning Poker (Покера планирования)**

Это одна из самых популярных техник оценки.
Участники процесса используют специально пронумерованные карты,
чтобы голосовать с их помощью за оценку задач.
Обычно для «покера» используются карты с числами Фибоначчи, но возможны и другие варианты.
Процесс оценки выглядит следующим образом:

- Каждый участник получает колоду карт с числовыми значениями для оценки.
- Кто-то делает краткий анонс очередной пользовательской истории и отвечает
  на вопросы команды по данной задаче.
- Участники «покера» выбирают карту с подходящей по их мнению оценкой
  и кладут их рубашкой вверх (чтобы не влиять на выбор друг друга).
- После того, как все члены команды выбрали свои оценки карты одновременно переворачиваются.
- Участникам с самыми низкими и высокими оценками делают краткие комментарии
  объясняя свой выбор оценки.
- В итоге процесса обсуждения команда приходит к единому решению и после этого переходит
  к следующей пользовательской истории.

**Bucket System (Система "ведерок")**

- Выберите случайным образом задачу из списка задач.
  Поместите его в ведро «?». Это наш первый справочный элемент.
- Таким же способом определить следующие 2 задачи
- После этого определен приблизительный вес задач и можно определить
  сложность оставшихся в соотношении с первыми 3мя
- Раздайте все оставшиеся предметы поровну всем участникам.
  Каждый участник ставит предметы на весы без обсуждения с другими участниками.
  Если у человека есть предмет, который он действительно не понимает,
  то этот предмет можно предложить кому-то другому.
- Все спокойно просматривают предметы в ведерках.
- Если участник находит неуместную эстимацию, он может поднят дискус с группой.
  Затем группа обсуждает его до тех пор, пока не будет достигнут консенсус.

**Dot-voting (Голосование по точкам)**

- Все оцениваемые задачи размещаются на столе\доске.
- Для выполнения оценки каждый из участников получает одинаковое количество «точек».
- Каждый член команды распределяет свои «точки» между задачами как он считает нужным,
  учитываю, что чем больше «точек», тем сложнее задача и тем больше на нее необходимо времени.
- После того как каждый участник сделал свою оценку и распределил все свои «точки»,
  подсчитывается общее количество точек выставленных для каждой пользовательской истории.
  В результате все задачи ранжируются между собой по количеству «точек».

**Maximum Size or Less (Разделение до максимального размера или меньше)**

- Вначале определяют максимально возможный размер для задачи
- Каждая история обсуждается всеми участниками, чтобы ответить на вопрос:
  оцениваемая задача больше максимального значения или меньше\равна ему?
- Если данная история больше максимального размера, то группа декомпозирует ее
  на подзадачи и повторяет процесс.
- Процесс продолжается пока все оцениваемые задачи не окажутся
  в разрешенном диапазоне размеров – будут равны или будут меньше
  выбранного за максимальное значения.

**Big/Small/Uncertain (Большой/Малый/Неопределенный)**

Данный метод похож на технику Bucket System, только используется 3 ведра:
большой размер, малый размер, неопределенный размер задачи.

- Все истории обсуждаются участниками и помещаются в одну из трех категорий.
- Сначала группа проводит групповое обсуждение нескольких первых задач (3-5),
  определяя масштаб и ориентиры для каждой категории.
- Затем, подобно Bucket System, оставшиеся истории распределяются между участниками
  и оцениваются самостоятельно, что сильно ускоряет процесс.

**Ordering Rule (Выстраивание порядка)**

- Сначала все оцениваемые истории выписываются на карточки.
- Карточки с задачами случайным образом размещаются на столе или доске со шкалой,
  на границах которой указаны «малый размер» и «большой размер».
- Каждый участник по очереди совершает свой «ход» оценки.
  Такой «ход» включает одно из следующих возможных действий:
  переместить любую историю по шкале на одно деление,
  обсудить историю с коллегами,
  пропустить свой «ход».
- В результате «ходов» сотрудников задачи могут перемещаться по доске,
  их оценка друг относительно друга уточняется.
- Когда все участники пропускают свой «ход», процесс оценки завершается.
  Все задачи распределены по шкале между значениями «малый размер» и «большой размер».


</details>

[//]: # (Стратегии ветвления)
<br>
<details>
    <summary>
        <b><big><big><big>
            Стратегии ветвления
        </big></big></big></b>
    </summary>

- Branching strategy описывает общие сценарии создания новых веток и связанные с ними необходимые действия.

Задачи:
- Разрешить параллельное развитие отдельных функций;
- Изолируйте изменения, не принятые изменения от кодовой базы;

![](https://elearn.epam.com/assets/courseware/v1/5298ff738434f41a954622922f539b9d/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/Branching_strategy_Branching.png)

- **ОДНОВЕТОЧНОЕ РАЗВИТИЕ** ветвления на основе магистрали нацелена
  на поддержание одной ветки разработки в работоспособном состоянии.
  Это сводит к минимуму количество других используемых ветвей,
  так как все разработчики фиксируются в одной общей ветке под контролем версий.

Ветка создается для выпуска, но только инженеры по выпуску могут работать в ветвях выпуска.
Они также могут выбирать отдельные коммиты из основной ветки в ветку выпуска.

Но ошибочный фикс почти мгновенно влияет на других разработчиков.

**По способу интеграции**
- Интеграция в общую магистраль
- Незавершенные функции в основной кодовой базе
- Небольшие, но частые слияния
- Высокая стоимость незавершенных работ

![](https://elearn.epam.com/assets/courseware/v1/9bdef8665c6aee2d14bb4f8c32ee10b2/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/Branching_strategy_single_branch.png)

- **СТРАТЕГИЯ ФУНКЦИОНАЛЬНЫХ ВЕТОК**

В центральном репозитории находится ветвь разработки,
в которой исходный код отражает состояние с последними внесенными изменениями.
Ветки функций используются для разработки новых функций.
Когда начинается разработка функции, целевая версия может быть неизвестна.
Суть функциональной ветки заключается в том, что она существует, пока функция находится в разработке.

Релиз в таких ветках - Ветви выпуска создаются из веток разработки.
Эти ветви могут существовать какое-то время, пока релиз не будет окончательно развернут.
В течение этого времени в этой ветке могут быть исправлены ошибки.
Добавлять сюда большие новые функции категорически запрещено.
Их нужно объединить в разработку, а значит, ждать следующего большого релиза.

**По способу интеграции**
- Отложенная интеграция, интегрировать функцию убедившись в ее завершении
- Изолируйте недоработанные функции
- Выберите функции для выпуска в случае интеграции
- Множество веток

- **Альтернатива GIT FLOW - GITHUB FLOW**
  В ответ на Git flow была описана более простая альтернатива, названная GitHub flow.
  Этот поток имеет только функциональные ветви и главную ветвь.
  Все, что находится в основной ветке, можно развернуть,
  поэтому для работы над чем-то новым создайте функцтональную ветку.
  Когда код будет готов, вы создаете запрос на слияние или вытягивание.

![](https://elearn.epam.com/assets/courseware/v1/55ccd11743fa796fe3769892b8729c8b/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/GitHub_flow.svg)

- **Альтернатива GIT FLOW - GITLUB FLOW**

GitLab предлагает создать ветки staging and production.
Когда кто-то хочет развернуть код на промежуточной стадии,
он создает запрос на слияние из основной ветки в предварительную.
А запуск кода происходит путем слияния промежуточной ветви с производственной.
Этот процесс гарантирует, что все было протестировано во всех средах

![](https://elearn.epam.com/assets/courseware/v1/29f33aa887951a29536c27e09a958b3c/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/GitLab_flow.svg)

</details>

</details>

[//]: # (Работа в команде)
<br>
<details>
    <summary>
        <b><big><big><big>
            Работа в команде
        </big></big></big></b>
    </summary>

[//]: # (Работа в команде в разработке программного обеспечения)
<br>
<details>
    <summary>
        <b><big><big><big>
            Работа в команде в разработке программного обеспечения
        </big></big></big></b>
    </summary>

Уже давно установлена взаимосвязь между различными аспектами
качества командной работы и результативностью команды

Для описания вводится термин Teamwork quality (TWQ)

TWQ состоит из:
- Коммуникация  - Частота, формализация и открытость обмена информацией.
- Координация   - Общее понимание при работе над параллельными подзадачами
  и соглашение об общих структурах, графиках, бюджетах и результатах.
- Баланс членского вклада.
  - Способность полностью использовать опыт членов команды.
  Вклады должны отражать конкретные знания и опыт члена команды.
- Взаимная поддержка       
  - Способность и готовность членов команды помогать и поддерживать
  друг друга в выполнении их задач.
- Усилие        - Способность и готовность членов команды распределять рабочую
  нагрузку и ставить задачи группы выше других обязательств.
- Сплоченность  - Мотивация членов команды поддерживать команду и признавать,
  что командные цели важнее индивидуальных.

</details>

</details>

[//]: # (EngX Bootcamp)
<br>
<details>
    <summary>
        <b><big><big><big>
            EngX Bootcamp
        </big></big></big></b>
    </summary>

[//]: # (Что такое EngX Bootcamp)
<br>
<details>
    <summary>
        <b><big><big><big>
            Что такое EngX Bootcamp
        </big></big></big></b>
    </summary>

Engineering Bootcamp был создан как инструмент, 
чтобы поделиться коллекцией лучших практик и инструментов, 
накопленных EPAM за последние 20 лет, 
и показать новым сотрудникам, как стать лучшими инженерами.

</details>

[//]: # (Engineering Culture)
<br>
<details>
    <summary>
        <b><big><big><big>
            Engineering Culture
        </big></big></big></b>
    </summary>

**Основная идея**
Основная идея инженерной культуры состоит в том, чтобы:
- Совершенствовать инженерную мысли.
- Предоставить необходимые навыки для всех работников.
- Поделиться лучшими инженерными практиками
- Улучшить культуру и образ мышления сотрудников
- Улучшение собственных практик, процессов, качества и контроль кода работников

В основном культура инженеров делится на **три категории**
- Культура разработчиков
    - Стандарты написания качественного кода
    - Юнит тестирование
    - Ревью чужого кода
- Основная инфроструктура
    - Стратегии релизов проекта
    - Неприрывная интеграция/доставка/поддержка конечного продукта
    - Среды разработки компании
- Качество конечного продукта
    - Обзор тестов
    - Автоматизированное тестирование
    - Не функциональное тестирование (NFR)

Так же Инженерная культура EPAM поддерживает развитие каждого участника процесса
Обучение -> Тестирование -> Повышение

Инженерная культура, **принципы**
- Автоматизируйте и тестируйте
- Code Review - жизненно важная практика для успешного развития
- Share - Поощряйте людей делиться тем, что они узнают, и помогайте другим изучать новые подходы.
- Simplify - Если вы знаете, как выполнять свою работу быстрее и проще без потери качества - сделайте это.
- Stay true - Нарушению принципов не может быть оправдания.

**Основные плюшки:**
- Чтобы убедиться, что каждый проект имеет 100% тестовое покрытие. Хороший код покрытый тестами код
- Ваш код легко читается и понимается. Вы делаете меньше переделок, меньше неоплачиваемых «рук помощи».
- Приводит к меньшему количеству сбоев, а также к эффективному обучению новичков.

**Выпуск продукта** - это процесс запуска нового продукта для определенного рынка или пользовательской базы.

**Выпуск программного обеспечения** - это развертываемый программный пакет,
являющийся результатом жизненного цикла программного обеспечения.

(!В чем отличие) - Выпуск продукта состоит из множества выпуска программного обеспечения.


</details>

[//]: # (Продолжительность цикла разработки)
<br>
<details>
    <summary>
        <b><big><big><big>
            Продолжительность цикла разработки
        </big></big></big></b>
    </summary>

**Короткий:** - функции следует развертывать как можно быстрее и качественно.
Для обеспечения основной работы, необходима полностью автоматизированная сборка и развертывание.
Разработка автоматических тестов должна начаться и продолжаться одновременно с разработкой функций.
Исходный код также должен постоянно находиться в готовом к выпуску состоянии.

Это дает нам:
- Быструю скорость принятия решений
- Быстрая обратная связь
- Высокая автоматизация всех аспектов

**Длинный:** - В случае если релиз поступает на какие-то жесткие носители. Например на
бортовой компьютер машины. Получить ошибку может слишком поздно, а главное исправление
такой ошибки будет очень дорогостоящей процедурой.
Потому команда должна следовать строгим процедурам,
проводить обширное тестирование и тщательно планировать выпуск.

- Строгие процессы
- Медленное время выхода на рынок
- Медленная обратная связь
- Дорого по доставке товара до конечного пользователя

</details>

[//]: # (Жизненный цикл релиза)
<br>
<details>
    <summary>
        <b><big><big><big>
            Жизненный цикл релиза
        </big></big></big></b>
    </summary>

- #### **Бизнес анализ (БА)**
    - Внедрение новой функции начинается с определения бизнес-потребностей и наброска решения бизнес-проблемы.
- #### **Разработка (Dev)**
    - Новая функция, улучшение или исправление реализованы и протестированы локально.
    - **Критерий контроля качества**
        - сборка возвращается с зеленым результатом
        - имеет необходимое покрытие модульного тестирования
        - успешно прошла экспертную проверку
- #### **AQA и QA тестирование**
    - Тестировщики тщательно тестируют приложение и убеждаются,
      что программное обеспечение работает должным образом.
    - **Критерий контроля качества**
        - необходимо убедиться что новая функция корректно работает
        - необходимо убедиться что ничего старого из-за этого не поломано
- #### **Промежуточный релиз**
    - Промежуточные среды стремятся выявить неисправные крайние случаи.
      Его среда должна быть аналогична той, которую получит пользователь.
      Это повысит качество выпускаемого продукта.
    - **Критерий контроля качества**
        - Убедиться, что продукт соответствует требованиям пользователя
        - Регрессионные тесты проверяют правильность разработанных и протестированных функций
        - Нагрузочные тесты проверяют, способна ли новая версия обслуживать ожидаемое количество запросов.
- #### **Production**
    - Только после этих этапов мы переходим к выпуску продукта

</details>

[//]: # (Доставка конечного продукта)
<br>
<details>
    <summary>
        <b><big><big><big>
            Доставка конечного продукта
        </big></big></big></b>
    </summary>

Доставка делится на два этапа
**Разработка** - используется система контроля версий (сокращенно VCS)
для эффективного хранения всех изменений кода, поступающих от инженеров.
Интеграционный сервер пытается сбилдить версию продукта,
выполняя тесты и проверки, чтобы обеспечить быструю обратную связь для команды.
Чтобы облегчить этот процесс, необходима автоматизированная сборка.

**Развертывание** - Артефакты, полученные в результате этого процесса сборки, хранятся в репозитории сборки,
что делает их доступными для развертывания в тестовой, промежуточной или производственной среде.


</details>

</details>

[//]: # (Контроль качества кода)
<br>
<details>
    <summary>
        <b><big><big><big>
            Контроль качества кода
        </big></big></big></b>
    </summary>

[//]: # (Контроль качества кода)
<br>
<details>
    <summary>
        <b><big><big><big>
            Контроль качества кода
        </big></big></big></b>
    </summary>

Хотя ошибки обходятся дорого, их исправление также является важной статьей затрат.
Здесь простой рабочий процесс показывает, сколько времени может потребоваться,
чтобы исправить действительную ошибку. Даже для мелких ошибок это может занять много времени.

![](https://elearn.epam.com/assets/courseware/v1/994a93f3b0991e271b997a637d959b17/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/BUG-FIXING_EFFORTS__2_.svg)

Реальность такова, что усилия по исправлению ошибок велики, но награда минимальна.
Одна из главных причин для раннего отслеживания и исправления ошибок заключается в том,
что небольшие проблемы в будущем могут превратиться в гораздо большие и требующие больше времени.
Проблема в том, что ошибка в дальнейшем может скрыть другие более большие ошибки
и их исправление будет стоить очень многого.

Достигается через
тестировавие
(функциональное нефункционально)
чек стайл
ревью
документация
тулзы проверки кода

</details>

[//]: # (Категории качества кода)
<br>
<details>
    <summary>
        <b><big><big><big>
            Категории качества кода
        </big></big></big></b>
    </summary>

**Качество функционального кода**

Это уровень соблюдения или выполнения функциональных требований.
Речь идет о том, «как работает код».

**Качество структурного кода**

Это качество написанного кода.
Итак, качество структурного кода - это то, «как он был написан».

</details>

[//]: # (Параметры хорошего кода:)
<br>
<details>
    <summary>
        <b><big><big><big>
            Параметры хорошего кода:
        </big></big></big></b>
    </summary>

- **Он работает.** (Код должен работать так, как ожидалось)
- **Легко обслуживать и менять** (Изменения кода стоит минимальное время)
- **Тестируемый** (Написан так чтобы его было легко тестировать)
- **Простой и Одиночный** (Код должен иметь простую логику и выполнять только одну задачу.
  Чтобы его можно было легко переиспользовать)
- **Легкочитаемый** (Это очень важно при внесении изменений в код.)
- **Приятно смотреть** (Используются все стандарты хорошего кода)

</details>

[//]: # (Почему это важно )
<br>
<details>
    <summary>
        <b><big><big><big>
            Почему это важно 
        </big></big></big></b>
    </summary>

Потому что большую часть времени при разработке проекта
тратиться на то чтобы понять существующий код.

![](https://elearn.epam.com/assets/courseware/v1/b7157d9e98886563ce9eeb675ac854f4/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/QC.WHY_IS_IT_IMPORTANT___1_.svg)

Если вы минимизируете время, необходимое для понимания кода,
это приведет к сокращению общего времени и усилий.
С другой стороны, низкое качество и ясность кода могут привести к:

- Функциональным дефектам
- Больше затрат и времени на внесение изменений
- Низкая производительность приложений
- Поддержка становится проблематичной

Качество кода стоит очень дорого но важно как в краткосрочной
так и в долгосрочной перспективе, для обеспечения маштабирования.

Поддержание качества кода - повседневная задача каждого разработчика.
Это включает в себя написание хорошего кода и выполнение проверки кода на каждом уровне.
Один из лучших способов сделать это - регулярно выполнять Code Review.

</details>

[//]: # (Стандарты кода)
<br>
<details>
    <summary>
        <b><big><big><big>
            Стандарты кода
        </big></big></big></b>
    </summary>

Код пишется не просто для решения бизнес-задачи.
Код должен быть доступен для чтения вашим коллегам-разработчикам.
Таким образом, каждый член команды должен согласовать стандарт,
прежде чем приступить к программированию.

При установке стандарта вы должны иметь в виду следующие **цели**:
- стиль исходного кода
- отступы между блоками кода
- использование пробелов вокруг операторов и ключевых слов
- использование регистра для классов или ключевых слов и имен переменных
- четкое описание названия классов/функций/процедур
- четкий стиль комментариев

**Помогает нам**
- Повышение ясности кода
- Повышение надежности и согласованности
- Повышение поддерживаемости кода
- Снизить сложность кода
- Создает общие соглашения между разработчиками программного проекта

**Code convention** - набор руководящих принципов для конкретного языка программирования,
которые рекомендуют практики и методы для каждого аспекта программы, написанной на этом языке.

В Code convention входят
- Организация файловой системы проекта
- Основные принципы программирования
- Лучшие архитектурные практики
- Слоевая стуктура проекта
- Комметирование кода

Написание чистого кода с самого начала проекта - это инвестиция в поддержку проекта,
поскольку новичку не придется тратить время на изучение кривого кода.
В большинстве унаследованных приложений стоимость изменений растет экспоненциально
из-за увеличения технических недочетов.

**Инструменты для обеспечения соблюдения стандартов кодирования**
Обеспечивается через:
- Через настройки IDE в которой ведется работа
- Путем интеграции сторонних инструментов в качестве подключаемых модулей к IDE

Это помагает:
- Лаконично реализовывать код
- Делать код более читаемый
- Делать код легко расширяемым и поддерживаемым
</details>

[//]: # (Code Review)
<br>
<details>
    <summary>
        <b><big><big><big>
            Code Review
        </big></big></big></b>
    </summary>

Делится на автоматическое и мануальное Review

**Автоматизированный анализ кода**

**Основная идея автоматизированного анализа кода** - это анализ программного кода
на соответствие заранее определенному набору правил и передовых практик
полностью автоматизированным способом.

**Автоматизированный анализ** кода так же используется для создания
полноценных отчетов о степени покрытости кода тестами и многом другом

- Помогают выявить/избежать дурнопахнущего кода
- Помогает выявить потенциальные баги
- Помогают выявить дыры безопасности

Но стоит помнить что автоматическое тестирование:
- не знает контекст задачи (не спосет от ошибок бизнес требований)
- не находит ошибок дизайна разработки ПО
- метрики должны быть правильно поняты, поскольку имеют большое значение

**Мануальный анализ кода**

Мануальный анализ кода - это систематическая проверка исходного кода.
Его цель - найти и исправить упущенные ошибки, а также улучшить общее качество кода.

**Преимущества:**
- **Экономия** (Если вы проверите код на более раннем этапе, затраты на исправление будут ниже)
- **Меньше багов** (Уменьшит количество ошибок, которые попадут в рабочую среду)
- **Взаимообучение** (Члены вашей команды могут учиться друг у друга, просматривая код друг друга.)
- **Качество кода** (читабельность, эффективность и ремонтопригодность
  чрезвычайно важны для вашего проекта в долгосрочной перспективе)
- **Стандарты безопасности и стрессоустойчивости**
  (Анализ кода также упрощает выявление потенциальных уязвимостей и их устранение до того,
  как они попадут на ваши серверы.)

**Что проверяется при ручной проверке кода:**
- Читаемость
- Функциональная корректность
- Полнота
- Скрытые последствия
- Стандарты кодирования
- Тесты
</details>

[//]: # (Качество продукта)
<br>
<details>
    <summary>
        <b><big><big><big>
            Качество продукта
        </big></big></big></b>
    </summary>


**Три показателя качества продукта:**
- Наличие дефектов - (Важно оценивать дефекты по степени их серьезности)
- Сравнение - сравнение продуктов из одного домена или одного и того же продукта с течением времени
- Эффективность локализации дефектов - он измеряет качество тестирования

**Как улучшить качество проекта?**
- **Отладка в наиболее популярных / «глючных» конфигурациях:**
  используя статистику дефектов, вы можете определить самые ошибочные конфигурации.
  Например если из всех браузеров все работает кроме Safari,
  то лучше отладить новую функцию в Safari,
  чтобы предотвратить множество специфичных для браузера дефектов.
- **Требования** - самая большая проблема всех проектов.
  Поэтому уточняйте требования заранее.
- **Ищите сложные области / формулировки, думайте, как их можно разработать и протестировать**,
  какие тестовые данные для этого нужны.
  Это может помочь нам избежать лишней работы в будущем
- **Чем раньше тестировщики получат код** для тестирования,
  тем раньше разработчики получат обратную связь.

![](https://elearn.epam.com/assets/courseware/v1/95d5bd6865cc6f7092f7a9652081379b/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/Ideal_testing_timeline_in_sprint__1_.svg)

**Как тестеры могут помочь разработчикам**
- **Заранее поделитесь чек-листами** - разработчики не обладают глубокими знаниями
  в различных методах тестирования и могут пропустить некоторые проверки
- **Давать советы по более детальному покрытию модульных тестов**
- **Иногда тестировщики лучше знают логику приложения и могут помочь
  с подготовкой некоторых конкретных тестовых данных.**
- **Тестировщики проводят анализ ошибок - они определяют самые проблемные области и конфигурации**

**Как разработчики могут помочь тестировщикам**
- Чем раньше код окажется у тестировщиков - тем лучше
- Могут предоставлять тстировщикам тестовые данные
- Предупредить о рискованных местах, в которых потенциально может случится ошибка

</details>

</details>

[//]: # (Наблюдаемость кода Logging/Трассировка/Мониторинг)
<br>
<details>
    <summary>
        <b><big><big><big>
            Наблюдаемость кода (Logging/Отслеживание Кода(трассировка)/Мониторинг)
        </big></big></big></b>
    </summary>

[//]: # (Logging)
<br>
<details>
    <summary>
        <b><big><big><big>
            Logging
        </big></big></big></b>
    </summary>

**Логирование** является мощным средством для понимания и отладки поведения программы во время выполнения. 
Журналы собирают и сохраняют важные данные и делают их доступными для анализа в любой момент времени.

Из логов которые я знаю могу назвать:
- Cloud Logging, почти каждое облачное решение имеет собственное логирование, например AWS CloudWatch
- Log4j

</details>

[//]: # (Отслеживание кода/Трассировка)
<br>
<details>
    <summary>
        <b><big><big><big>
            Отслеживание кода/Трассировка
        </big></big></big></b>
    </summary>

Когда журнала логов может быть не достаточно чтобы понять то, что вызвало ошибку, 
в дело вступают библиотеки трассировки. 

**Основная цель трассировки** — отследить движение данных и программный поток приложения. 
В связи с этим гораздо больше информации охватывается при отслеживании.

Трассировку можно обеспечить:
- дебагом. В определенный момент остановить приложение и посмотреть актуальное состояние
- JVM view. Позволяет мониторить и смотреть за потоком данных

</details>

[//]: # (Мониторинг)
<br>
<details>
    <summary>
        <b><big><big><big>
            Мониторинг
        </big></big></big></b>
    </summary>

Использование специализированных программ, для сбора, хранения и агрегирования информации
которая может показать уязвимости, просадки перфоманса, проблемные точки многопоточности и другие метрики

Тулы которые часто используют:
- Java VisualVM
- JProfiler
- LightStep
- Pinpoint
- MoSKito

Для cloud:
- Amazon Cloudwatch
- AWS X-Ray

Мониторы разделяются на push и pull

**Push** мониторы имеют пуш агента, которому данные сами отправляют значения для мониторинга
**Pull** мониторы сами толкают существующих агентов чтобы те дали информацию 

![](https://yqintl.alicdn.com/e2a305b3d74836429aa6bdb64b2042a454d73ad4.png)

</details>

[//]: # (Лучшие советы по мониторингу приложений)
<br>
<details>
    <summary>
        <b><big><big><big>
            Лучшие советы по мониторингу приложений
        </big></big></big></b>
    </summary>

- не забывать про логирование
- оптимизировать журнал логов
- найдите и устраните узкие места производительности
- повысьте эффективность отслеживания исключения 
  (code analysis, informative log, tech sessions with team)

</details>

</details>

[//]: # (CI/CD)
<br>
<details>
    <summary>
        <b><big><big><big>
            CI/CD
        </big></big></big></b>
    </summary>

[//]: # (CI)
<br>
<details>
    <summary>
        <b><big><big><big>
            CI
        </big></big></big></b>
    </summary>

**Непрерывная интеграция** (CI, англ. Continuous Integration) —
и **выполнении частых автоматизированных сборок проекта** для скорейшего
выявления потенциальных дефектов и решения интеграционных проблем.
(например при частом слиянии фича бранчей с основной)

**Смысл CI** - **в быстром составлении фидбэка для разработчиков.**

Дело в том, что стадия интеграции может непредсказуемо задержать окончание работ.
Переход к непрерывной интеграции позволяет снизить трудоёмкость интеграции и
сделать её более предсказуемой за счёт наиболее раннего обнаружения и устранения ошибок
и противоречий, но основным преимуществом является сокращение стоимости исправления дефекта,
за счёт раннего его выявления.

**Для организации процесса CI** непрерывной интеграции на выделенном сервере **запускается служба**,
в задачи которой входят:
- Включаются определенные виды тестов (которые проходят быстрее всего)
- получение исходного кода из репозитория;
- сборка проекта;
- выполнение тестов;
- развёртывание готового проекта;
- отправка отчетов.

**преимуществам**:
- проблемы интеграции выявляются и исправляются быстро, что оказывается дешевле;
- немедленный прогон модульных тестов для свежих изменений;
- постоянное наличие стабильной версии
- немедленный эффект от неполного или неработающего кода приучает разработчиков
  к работе в итеративном режиме с более коротким циклом.

При этом, практика не лишена недостатков, в частности:

- значительные затраты на поддержку работы непрерывной интеграции;
  необходимость в дополнительных вычислительных ресурсах под нужды непрерывной интеграции;


</details>

[//]: # (CD)
<br>
<details>
    <summary>
        <b><big><big><big>
            CD
        </big></big></big></b>
    </summary>

**Непрерывная доставка** (Continuous Delivery) - это подход к разработке программного обеспечения,
при котором все изменения, включая новые функции, изменения конфигурации,
исправления ошибок и эксперименты - поставляются пользователям максимально быстро и безопасно.

**Непрерывная развертывание** (Continuous Deployment) – это практика автоматизации всего процесса релиза ПО.
Идея заключается в том, чтобы выполнять CI, плюс автоматически готовить и вести релиз к продакшену.

При этом желательно добиться следующего: любой, кто обладает достаточными привилегиями
для развертывания нового релиза может выполнить развертывание в любой момент,
и это можно сделать в несколько кликов.
Программист, избавившись практически от всей ручной работы, трудится продуктивнее.

![](https://wac-cdn.atlassian.com/dam/jcr:b2a6d1a7-1a60-4c77-aa30-f3eb675d6ad6/ci%20cd%20asset%20updates%20.007.png?cdnVersion=676)


</details>

</details>

</details>

