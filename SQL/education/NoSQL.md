<h1>NoSQL</h1> 
<h4> 

[Back to menu](..%2FMenu.md)

</h4>

[//]: # (Что такое NoSQL)
<br>
<details>
    <summary>
        <b><big><big><big>
            Что такое NoSQL
        </big></big></big></b>
    </summary>

NoSQL (Not only SQL) - это ряд технологий, подходов, проектов
имеющих существенные отличия от
традиционных СУБД, работающих с языком SQL.

предлагают решения в хранении и управлении данными
в зависимости от необходимости

- "ключ-значение" (key-value store)
  (большая хеш-таблица, содержащая ключи и значения)

- документно-ориентированные (document store)
  (хранит документы, состоящие из тегированных элементов (JSON))

- хранилища семейств колонок (column database)
  (в каждом блоке хранятся данные только из одной колонки)

- графовые базы данных (graph database)
  (сетевая база данных, которая использует узлы и рёбра для отображения и хранения данных)


</details>

[//]: # (Какие проблемы решает NoSQL основные отличия от SQL)
<br>
<details>
    <summary>
        <b><big><big><big>
            Какие проблемы решает NoSQL (основные отличия от SQL)
        </big></big></big></b>
    </summary>

- **schemaless**.
  В отличие от реляционных структура данных не регламентирована
  — в отдельной строке или документе можно добавить произвольное поле
  без предварительного декларативного изменения структуры всей таблицы.

Пример такого изменения на Mongo:

    BasicDBObject order = new BasicDBObject();
    order.put(“totalSum”, total); // раньше мы использовали просто “sum”

решает проблему изменчивости (если база часто меняется)

- **Представление данных в виде агрегатов**.
  NoSQL хранилища оперируют данными(таблицами) как с целостными объектами

Что это нам дает?:

Из минусов:
- Оптимизация только под определенный тип запросов
  (Вставка начинает страдать из-за отсутствия нормализации, но селект работает лучше)
- Сложность в обновлении денормализованных данных

Из плюсов:
- Это дает возможность создания распределенной среды
- В распределенной среде обеспечивается высокая скорость чтения
- Храним объект в том виде, в котором работает приложение

- **Слабые ACID свойства**.
  Мы получаем консистентность (получение максимально актуальных данных)
  в обмен на доступность (гарантия того, что запрос выполниться)

- **Возможность создания распределенных систем**
  С лавинообразным ростом информации в мире и необходимости ее обрабатывать
  за разумное время встала проблема вертикальной
  масштабируемости — рост скорости процессора остановился на 3.5 Ггц,
  скорость чтения с диска также растет тихими темпами,
  плюс цена мощного сервера всегда больше суммарной цены нескольких простых серверов.
  В этой ситуации обычные реляционные базы, даже кластеризованные на массиве дисков,
  не способны решить проблему скорости, масштабируемости и пропускной способности.

Единственный выход из ситуации — горизонтальное масштабирование,
когда несколько независимых серверов соединяются быстрой сетью
и каждый владеет/обрабатывает только часть данных и/или только часть
запросов на чтение-обновление. В такой архитектуре для повышения мощности хранилища
(емкости, времени отклика, пропускной способности)
необходимо лишь добавить новый сервер в кластер — и все.

</details>

[//]: # (Понятие "Репликация", Виды репликации)
<br>
<details>
    <summary>
        <b><big><big><big>
            Понятие "Репликация", Виды репликации
        </big></big></big></b>
    </summary>

Репликация — копирование данных на другие узлы при обновлении.

**master-slave:**
- Есть master сервер который берет на себя функции чтения и записи данных.
- Есть slave сервера которые являются (или получают) реплики мастер сервера
  и с их стороны работает только чтение.

![text-img](https://hsto.org/storage2/fe3/70f/649/fe370f6495f0fccdeb9fe7ac303b2fc9.jpg)

предполагает хорошую масштабируемость на чтение (может происходить с любого узла),
но немасштабируемую запись (только в мастер узел).
Также есть тонкости с обеспечением постоянной доступности
(в случае падения мастера либо вручную, либо автоматически
на его место назначается один из оставшихся узлов).

**peer-to-peer:**
предполагается, что все узлы равны и могут обслуживать как запросы на чтение, так и на запись.

![text-img](https://hsto.org/storage2/7ce/408/bb3/7ce408bb336eb974a0bc50db54f5a4a5.jpg)

- из минусов, мы повышаем накладные расходы на репликацию

</details>

[//]: # (Понятие "Шардинг", Виды шардинга)
<br>
<details>
    <summary>
        <b><big><big><big>
            Понятие "Шардинг", Виды шардинга
        </big></big></big></b>
    </summary>

**Шардинг** — разделение данных между серверами
С ростом количества данных, один сервер не может хранить все данные.
А вертикальное масштабирование сервера является слишком дорогим.

Шардинг решает проблему путём горизонтального масштабирования.
Благодаря данному механизму мы можем подключать дополнительные
сервера для хранения, записи и чтения данных.
(Обработка запросов все еще на корневом узле)

(В NoSQL системах, шардинг является автоматическим)

**Вертикальный шардинг** - это выделение таблицы или группы таблиц на отдельный сервер.

**Горизонтальный шардинг** — это разделение одной таблицы на разные сервера.
Это необходимо использовать для огромных таблиц, которые
не умещаются на одном сервере.
Разделение таблицы на куски делается по такому принципу:

- На нескольких серверах создается одна и та же таблица (только структура, без данных).
- В приложении выбирается условие, по которому будет
  определяться нужное соединение (например, четные на один сервер, а нечетные — на другой).
- Перед каждым обращением к таблице происходит выбор нужного соединения.

- из минусов теряем данные если сервак выйдет из строя

</details>

[//]: # (Понятие "Агригации" )
<br>
<details>
    <summary>
        <b><big><big><big>
            Понятие "Агригации" 
        </big></big></big></b>
    </summary>

Агригация - коллекция связанных объектов,
которая интерпретируется как единое целое.

Простым примером арегации в SQL DB являются атомарные функции (MIN, MAX, COUNT)

В NoSQL системах в которых отсутствует понятия схем, все базируется на агригированных данных
которые на примере Mongo выглядят следующим образом

    // Клиенты {
    "customer": {
    "id": 1,
    "name": "Martin",
    "billingAddress":	[{"city": "Chicago"}],
    "orders":	[
       {
          "id":99,
          "customerld":1,
          "orderIterns":[
          {
             "productld":27,
             "price": 32.45,
             "productName": "NoSQL Distilled"
          }
       ],
       "shippingAddress":[{"city":"Chicago"}]
          "orderPayment":[
          {
             "ccinfo":"1000-1000-1000-1000",
             "txnId":"abelif879rft",
             "billingAddress" : { "city" : "Chicago" }
          }],
       }]
      }
    }

</details>

[//]: # (NoSQL CAP теорема)
<br>
<details>
    <summary>
        <b><big><big><big>
            NoSQL CAP теорема
        </big></big></big></b>
    </summary>

Благодаря появлению распределительных систем и параллельной обработке данных
стало возможным горизонтальное маштабирование системы. Когда система наращивает
вычислительную способность благодаря не качеству а количеству задействованных единиц.

Но при горизонтальном масштабировании есть свои минусы и потому для того
чтобы количественно определить неизбежные компромиссы таких систем сущесвует CAP

В CAP говорится, что в распределенной системе возможно выбрать только 2 из 3-х свойств:

- C (consistency) — согласованность. Каждое чтение даст вам самую последнюю запись.
- A (availability) — доступность. Гарантия того что каждый клиент имеет
  возможность чтения и записи запроса.
- P (partition tolerance) — устойчивость к разделению.
  (Потеря сообщений между компонентами системы не влияет на работоспособность системы.
  В том числе и выход из строя каких-то компонентов)

SQL базы - CA
NoSQL базы - CP

![alt-text](https://www.bigdataschool.ru/wp-content/uploads/2019/12/cap_0.png)

- **CA** (Availability + Consistency — Parition tolerance) Реализуя свойства транзакционности
  и ACID система получает согласованность и доступность, но горизонтально маштабирование
  становится дорогостоящей (перфоманс) операцией.
- **CP** (Consistency + Partition tolerance — Availability)
  Система продолжает корректно читать данные даже при отказе одного из серверов.
  Но в этом случае запись будет обрываться или сильно задерживаться, пока система
  не убедится в своей целостности и согласованности. Но при этом будет отвечать на чтение
  поскольку на сервер представляет из себя репликацию.
- **AP** (Availability + Partition tolerance — Consistency)
  База имеет возможность разделения и гарантирует то, что каждый запрос на чтение и запись
  кореектно отработает, но не гарантирует что данные при чтении будут актуальными.


</details>

[//]: # (NoSQL vs SQL Области применения)
<br>
<details>
    <summary>
        <b><big><big><big>
            NoSQL vs SQL (Области применения)
        </big></big></big></b>
    </summary>

В заключении темы отвечая на вопрос выбора между NoSQL и SQL.
Лучшим вариантом будет работа NoSQL и SQL в спайке.
Разделенный на несколько независимых сервисов проект всегда нуждается в
структурированности и защите обеспечиваемой SQL базами. Но и в то же время
разделенность серверов и репликации мастер сервера обеспечивают так необходимую
скорость работы, и в грамотном сочетании проект начинает работать с тем что конкретно ему надо.

Но и ситуации когда NoSQL и SQL базы тоже возникают из-за неНеобходимости в каких-то
конкретных функциях. Скажем мобильный рынок который не базируется на клиент серверной архитектуре
больше предпочтет SQLite из-за своей легковесности и скорости.

</details>