### Что такое SQL

SQL (structured query language) - специальный язык, используемый для работы с базами данных.
С помощью SQL можно задавать структуру базы, организовывать выборку данных 
по каким-то определённым критериям, удалять и изменять данные.

### Что такое СУБД

СУБД (Система Управления Базами Данных) - программное обеспечение, которое взаимодействует
с пользователем, приложениями и самой базой данных для сбора и анализа данных. 
СУБД позволяет пользователю взаимодействовать с базой данных. 
Данные, хранящиеся в базе данных, могут быть изменены, извлечены и удалены.

СУБД == SQL Server

#### Основные функции СУБД

- управление данными БД;
- логирование изменений;
- резервное копирование и восстановление базы данных после сбоев;
- поддержка языков БД.

#### Типы СУБД

**Реляционная (RSQL)** - поддерживает SQL. 
Отношения между объектами выглядит как таблицы которые 
связаны между собой PK и FK отношениями

**Нереляционная (NoSQL)** - частично поддерживает SQL (не все виды)
Отношения между объектами представлены как нереляционные это могут быть
таблицы, единый документ (json) или описываться xml и так далее 

#### SQL vs NoSQL

- **Вертикальное масштабирование** — заменять в существующей вычислительной 
системе компоненты более мощными и быстрыми 
- **Горизонтальное масштабирование** - разбиение системы на более мелкие структурные компоненты и 
разнесение их по отдельным физическим машинам (увеличение количества серверов)

SQL:

Плюсы:
+ Структурированность хранения данных
+ SQL стандартный язык запросов (при переходе от одной SQL БД к другой, изменения будут минимальны)
+ Хорошая вертикальная масштабируемость
+ Они надежны
+ Имеют хорошую поддержку из-за того что существуют достаточно давно
+ Позволяют решать достаточно сложные задачи

Минусы:
- Плохая горизонтальная масштабируемость
- Из-за того что данные распределены по таблицам, может проседать скорость работы
- Достаточно сложная работа с большой базой

NoSQL: подходят для многих мобильных, игровых, интернет‑приложений, 
когда **требуются гибкие масштабируемые** базы данных **с высокой производительностью** 
и широкими функциональными возможностями, способные обеспечивать **максимальное удобство использования.**

Плюсы:
+ Отличная масштабируемость как вертикально так и горизонтально
+ Гибкая разработка (проходит быстрее)
+ Высокая производительность
+ Широкие функциональные возможности

Минусы:
- Неструктурное хранение данных
- Каждая NoSQL база имеет свой способ работы с данными
- Плохая надежность
- Не очень хорошая поддержка из-за того что некоторые NoSQL еще молодые
- Сложно решать сложные задачи

#### Примеры SQL и NoSQL

SQL:
- Amazon
- Oracle
- MS SQL
- MySQL
- Postgres

NoSQL:
- SQLite
- MongoDB
- Reddis

### Понятие таблицы/поля

Таблица - Структура которая хранит данные
Поля    - Внутренняя единица таблицы (Таблица состоит из полей)

### Из каких подмножеств состоит SQL (DDL/DML/DCL/TCL)

- DDL (Data Definition Language, язык описания данных) 
    позволяет выполнять различные операции с базой данных, 
    такие как CREATE (создание), ALTER (изменение) и DROP (удаление объектов).
- DML (Data Manipulation Language, язык управления данными) 
    позволяет получать доступ к данным и манипулировать ими, 
    например, вставлять, обновлять, удалять и извлекать данные из базы данных.
- DCL (Data Control Language, язык контролирования данных) 
    позволяет контролировать доступ к базе данных. 
    Пример — GRANT (предоставить права), REVOKE (отозвать права).
- TCL (Transaction Control Language) - контроль над DML командами
    Пример - СOMMIT/ROLLBACK
    
#### Ключевые слова DDL

Ключевые слова это Create/Alter/Drop/Truncate
    
### Типы данных SQL

Числовые:
- BIT:              хранит значение 0 или 1.
- TINYINT:          хранит числа от 0 до 255.
- SMALLINT:         хранит числа от –32 768 до 32 767.
- INT:              хранит числа от –2 147 483 648 до 2 147 483 647.
- BIGINT:           хранит очень большие числа от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
- DECIMAL:          хранит числа c фиксированной точностью.
Данный тип может принимать два параметра precision и scale: DECIMAL(precision, scale).
Параметр precision представляет максимальное количество цифр, которые может хранить число.
Параметр scale представляет максимальное количество цифр, которые может содержать число после запятой.
- NUMERIC:          данный тип аналогичен типу DECIMAL.
- SMALLMONEY:       хранит дробные значения от -214 748.3648 до 214 748.3647.
- MONEY:            хранит дробные значения 
- FLOAT:            хранит дробные значения
- REAL:             Эквивалентен типу FLOAT(24)

Дата/Время:
- DATE:             хранит даты от 0001-01-01
- TIME:             хранит время в диапазоне от 00:00:00.0000000
- DATETIME:         хранит даты и время от 01/01/1753
- SMALLDATETIME:    хранит даты и время в диапазоне от 01/01/1900
- DATETIMEOFFSET:   хранит даты и время в диапазоне от 0001-01-01
- TIMESTAMP:        число, которое хранит номер версии строки в таблице

Строковые типы данных:
- CHAR:             хранит строку длиной от 1 до 8 000 символов (не хранит Unicode)
- VARCHAR:          хранит строку (не хранит Unicode)
- NCHAR:            хранит строку в кодировке Unicode
- NVARCHAR:         хранит строку в кодировке Unicode

Бинарные типы данных:
- BINARY:           хранит бинарные данные
- VARBINARY:        хранит бинарные данные

Остальные типы данных:
- UNIQUEIDENTIFIER: уникальный идентификатор GUID (по сути строка с уникальным значением)
- CURSOR:           представляет набор строк
- GEOGRAPHY:        хранит географические данные, такие как широта и долгота.
- GEOMETRY:         хранит координаты местонахождения на плоскости.

#### DATETIME vs TIMESTAMP

DATETIME диапазон: от 1000-01-01 00:00:00 до 9999-12-31 23:59:59.
Это время не зависит от временной зоны. 
Оно всегда отображается при выборке точно так же, как было сохранено, 
**независимо от того какой часовой пояс установлен в СУБД**

TIMESTAMP диапазон от «1970-01-01 00:00:01» UTC до «2038-01-19 03:14:07» UTC ».
**При получении из базы отображается с учётом часового пояса.**

#### CHAR vs VARCHAR

CHAR - Количество символов, которое может хранить столбец, передается в скобках. 
Например, для столбца с типом CHAR(10) будет выделено 10 байт. 
И если мы сохраним в столбце строку менее 10 символов, то она будет дополнена пробелами.

VARCHAR - В отличие от типа CHAR если в столбец с типом VARCHAR(10) 
будет сохранена строка в 5 символов, то в столце будет сохранено именно пять символов.

- Почему полностью не избавиться от CHAR
    - CHAR работает на 50% быстрее потому что он работает со статическими кусками памяти
    - VARCHAR работает медленне поскольку работает с динамикой
    
(советуется использовать CHAR при повторяющихся статических данных)

### Простой пример создания таблицы   

    CREATE TABLE Persons (
        Personid int NOT NULL AUTO_INCREMENT,
        LastName varchar(255) NOT NULL,
        FirstName varchar(255),
        Age int,
        PRIMARY KEY (Personid)
    );
    
#### VIEW таблицы

VIEW в SQL являются своего рода виртуальными таблицами. 
Мы можем создать VIEW, из нескольких таблиц, представленных в базе данных
на основе определенных условий.

    CREATE VIEW DetailsView AS
    SELECT NAME, ADDRESS
    FROM StudentDetails
    WHERE S_ID < 5;
    
    SELECT * FROM DetailsView;
    
#### Materialized View vs View

View:
- View таблицы никогда не сохраняются, только отображается.
- Представление - это виртуальная таблица, 
сформированная из одной или нескольких базовых таблиц или представлений

+ Представление обновляется каждый раз, когда используется виртуальная таблица 
+ Не требует дискового пространства для хранения
- (Главное) Медленная обработка

Materialized View:
- Материализованное представление хранится на диске.
- Материализованное представление является физической копией базовой таблицы (На момент создания)
- Материализованное представление должно обновляться вручную или с использованием триггеров.

+ Быстрая обработка
+ Материализованный вид использует пространство памяти.

### Понятие целостности данных

Целостность данных – это полнота, точность и единообразие данных. 
Для поддержания целостности данных в реляционных БД используется ряд инструментов. 
Целостность данных обеспечивается при помощи constraint. 
Эти ограничения целостности позволяют применять практические правила к данным в таблицах 
и гарантировать точность и надежность данных. 

#### Что такое сущности и отношения

Сущности: То, из чего состоит любая база данных
Равносильно классам в ООП. А объекты классов это строки в БД.

Отношения: Это то, как сущности связаны между собой. 
Отношения один к одному. И один ко многим.

#### Ограничения (constraints)

Ограничения (constraints) используются для указания ограничения на тип данных таблицы. 
Они могут быть указаны при создании или изменении таблицы. Пример ограничений:

- NOT NULL      - гарантирует, что столбец не может иметь значение NULL
- UNIQUE        - гарантирует, что все значения в столбце разные
- PRIMARY KEY   - комбинация NOT NULL и UNIQUE. Уникально идентифицирует каждую строку в таблице
- FOREIGN KEY   - уникально идентифицирует строку / запись в другой таблице
- CHECK         - Гарантирует, что все значения в столбце удовлетворяют определенному условию
- DEFAULT       - устанавливает значение по умолчанию для столбца, если значение не указано
- INDEX         - используется для очень быстрого создания и извлечения данных из базы данных
- AUTO_INCREMENT- позволяет автоматически генерировать уникальный номер 
при добавлении новой записи в таблицу.

#### Индексирование колонок

Индексы являются методами повышения производительности, позволяя извлекать 
информацию из базы данных с более высокой скоростью и производительностью.

Индекс базы данных во многом сходен с индексом (алфавитным указателем) книги. 
Когда нам нужно быстро найти какую-либо тему в книге, мы сначала смотрим в индексе, 
на каких страницах книги эта тема рассматривается, а потом сразу же открываем нужную страницу. 
Подобным образом, при поиске определенной строки таблицы компонент 
Database Engine обращается к индексу, чтобы узнать ее физическое местонахождение.

Индексы имеют две особенности
- Пользователь БД не имеет возможности выбирать поиск по индексу или нет
Для него система индексирования скрыта, а ей занимается система оптимизирования щапросов

- Индекс базы данных могут меняться при каждом изменении соответствующих данных.

Индекс помогает ускорить запросы на получение данных (SELECT [WHERE]), 
но замедляет процесс добавления и изменения записей (INSERT, UPDATE) поскольку таблица при добавлении
так же обновляет индексы.

#### Полное сканирование vs Индексирование

Если для таблицы отсутствует подходящий индекс, для выборки строк система использует
метод полного сканирования таблицы. 
Система последовательно извлекает и исследует каждую строку таблицы
(от первой до последней), и помещает строку в результирующий набор, 
если для нее удовлетворяется условие поиска в предложении WHERE. 
Таким образом, все строки извлекаются в соответствии с их физическим расположением в памяти.
Этот метод менее эффективен, чем доступ с использованием индексов

Индексы сохраняются в дополнительных структурах базы данных, называющихся страницами индексов. 
Для каждой индексируемой строки имеется элемент индекса (index entry), 
который сохраняется на странице индексов. 
Каждый элемент индекса состоит из ключа индекса и указателя.

Поиск же записей по индексированной таблице осуществляется по сбалансированному АВЛ дереву.

(У каждого узла такого дерева не больше двух узлов, максимум левый и правый
правила которого звучак как Не меньше и Не больше а каждая ветвь дерева 
ниже составляет собственное дерево)

Главное отличие полного сканирования от индексирования в том
Что поиск полного сканирования составляет N
Сложность сканирования по дерева стремиться к LogN и зависит от высоты дерева

#### Типы индексов

Всего существует два типа индексов – кластеризованные, некластеризованные.

- **Кластеризованный** индекс говорит нам о том, что записи физическии 
(на диске) будут храниться рядом друг с другом.
Кластеризованный индекс может быть только один 
и создается по умолчанию для каждой таблицы, которая имеет первичный ключ.

Кластеризованный индекс хранит реальные строки данных в листьях индекса.

- **Некластеризованного** индекс содержит только те столбцы, 
по которым определен данный индекс, 
а также содержит указатель на кластерный индекс если он есть или на номер строки.

- **Составной индекс** Такой индекс может содержать более одного столбца. 
Вы можете включить до 16 столбцов в индекс, но их общая длина ограничена 900 байтами. 
Как кластеризованный, так и некластеризованный индексы могут быть составными.

- **Уникальный индекс** Уникальный индекс автоматически создается когда вы 
определяете ограничения столбца: первичный ключ или ограничение на уникальность значений

#### Транзакции

Транзакция в базе данных – это логическая задача состоящая из каких-то операций над БД. 
Транзакция представляет собой **неделимое действие**, то есть она должна быть выполнена как единое целое. 

#### Свойство ACID

Для целостности данных все транзакции в БД должны соответствовать требованиям ACID, т.е.:
- Atomicity (Атомарность)
- Consistency (Консистентность)
- Isolation (Изоляция)
- Durability (Надежность)
    
 Подробнее:   
    
- Атомарность   – Либо транзакция проходит целиком, либо отменяется целиком 
    в случае ошибки в цепи операций
    (перфоманс: )
- Consistency   - Все данные, записываемые в БД в рамках транзакции, должны соответствовать 
    всем правилам и ограничениям, включая ограничения целостности, каскады и триггеры.
    (перфоманс: валидации)
- Isolation     - Во время выполнения транзакции параллельные транзакции не должны оказывать 
    влияние на её результат.
    (перфоманс: сложно реализации изоляции сами по себе бьют по перфомансу)
- Durability    - Если транзакция отработала полностью и завершилась, то все ее изменения
должны быть сохранены и считаются постоянными 
    (перфоманс: проблема оптимизации запросов)

#### Уровни изолированности (добавить проблемы)

- Read uncommitted
Самая плохая согласованность данных (самая высокая скорость)
каждая транзакция видит незафиксированные изменения другой транзакции (феномен грязного чтения)

- Read committed
Для этого уровня параллельно исполняющиеся транзакции видят только 
зафиксированные изменения из других транзакций
  (работа с разными данными)

- Repeatable read
мы не видим в исполняющейся транзакции измененные и удаленные записи другой транзакцией. 
Но все еще видим вставленные записи из другой транзакции
  (фантомные строки)

- Serializable
Уровень, при котором транзакции ведут себя как будто ничего более не существует,
никакого влияния друг на друга нет.

### Что такое нормализация БД и каковы ее приемущества

Плюсы:
+ Нормализация нужна для борьбы с избыточностью
+ Как следствие, повышается читаемость самой базы и интуитивность
+ Упрощение расширения и маштабирования
+ Упрощение применения процедур целостности (constraint)
+ Проецирование на языки программирования

Минусы:

- Множество таблиц влияют на производительность всей системы
- Возростает сложность запросов, поскольку надо объединять таблицы

#### Основные принципы и определения нормализации

**Первая нормальная форма**

4Правиль атомарности значений (Составные данные в одной колонке)

- **Правило атомарности значений**
- Нет повторяющихся строк
- Строки таблиц не должны зависеть друг от друга
- Порядок строк не должен влиять на понимание информации.
- Порядок столбцов не должен влиять на понимание информации.
- Каждая строка должна быть уникальна, поэтому для нее определяется первичный ключ. 
- Первичный ключ не может повторяться в пределах таблицы и служит идентификатором записи.

**Вторая нормальная форма**

- Отношение находится во 2НФ, если оно находится в 1НФ и 
каждый не ключевой атрибут неприводимо зависит от Первичного Ключа (ПК)

т.е. каждый столбец зависит от всего ключа, а не от его части. 

неключевой зависит от части составного ключа

В ситуации когда есть таблица и скидка предоставляется сразу на весь товарный ряд

Модель  | Фирма | Цена | Скидка
X1      | Z     | 1    | 5%
X2      | M     | 2    | 3%

Фирма скидка в этом примере должно быть вынесено

**Третья нормальная форма**

- Отношение находится в 3НФ, когда находится во 2НФ 
и каждый не ключевой атрибут нетранзитивно зависит от первичного ключа.

неключевой относиться к ключевому через неключевой - это нарушение

т.е. вся таблица не содержит производных данных
(т.е. все данные которые остаются в таблицы напрямую связаны с PK)

Модель  | Магазин   | Телефон
X1      | Address1  | 11
X2      | Address2  | 22

**Четвертая нормальная форма**

- **Простыми словами 4NF описывает отношение между полями в ситуации когда 
это не может быть решено как в 2NF и 3NF вынесением одной связи в другую таблицу**

- Четвертая нормальная форма, отношения которые не содержат повторяющиеся наборы данных.
(многозначные значения)

Пример:

    ========================================================
    Преподаватель|Дисциплина                    |Написанная им методичка
    К            |Программирование              |Основы БД
    К            |Программирование              |Теорию ООП
    К            |Основы Вычислительных техник  |Теорию ООП

Ошибки:
    1. Многозначные значения приводят к дублированию данных
    2. Решить эту проблему вынесением одного из полей в отдельную таблицу не представляется возможным
    (нет возможности 2 нормальной формы)

Решением:
   
Вынесение обеих таблиц по их отношению к PK
т.е. приведение к
   
    =====================================           |=========================
    Преподаватель   |Дисциплина         |           |Преподаватель  |Написанная им методичка
    К               |Программирование   |           |К              |Основы БД
    k               |Основы вт          |           |К              |Теорию ООП
    
**Пятая нормальная форма**

**Простыми словами (5NF описывает ситуацию 4NF но, без возможности разбиения только на 2 проекции)**

При приведении отношения ко предыдущим NF использовалась декомпозиция отношения на две проекции.
(разбиение внутреннего отношения между полями на 2 зависимых табличных отношений) 

Но существуют отношения, для которых невозможно выполнить декомпозицию на две проекции без потерь.
В то же время над такими отношениями можно выполнить декомпозицию на большее количество 
проекций без потерь, каждая из которых обладает лучшими свойствами. 

Данный факт принято называть зависимостью по соединению, 
а подобные отношения называются 3-декомпозируемыми отношениями 
(любое отношение называется n-декомпозируемым при ).

Пример:

Возьмем как пример предыдущую таблицу, но поменяем условия связи
Теперь курс обязан перечислять методички которые задействованы в процессе изучения курса

Исходная таблица:

    ====================================================================
    Преподаватель|Дисциплина                    |Методичка
    К            |Программирование              |Основы БД
    К            |Программирование              |Теорию ООП
    К            |Основы Вычислительных техник  |Теорию ООП

Теперь разбить только на отношения 
- Преподаватель -> Дисциплина
- Преподаватель -> Методичка

Не имеется возможным, поскольку мы теряем условие связи Дисциплины и методичек

как итог, появляется решение:

    =====================================           |=========================
    Преподаватель   |Дисциплина         |           |Преподаватель  |Методичка
    К               |Программирование   |           |К              |Основы БД
    k               |Основы вт          |           |К              |Теорию ООП
    
    ===============================
    Дисциплина         | Методичка
    Программирование   | Основы БД
    Основы вт          | Теорию ООП

**Шестая нормальная форма**

**Шестая нормальная форма - когда она неприводима, 
то есть не может быть подвергнута дальнейшей декомпозиции без потерь.** 

#### Денормализация

Денормализация — намеренное приведение структуры БД в состояние,
не соответствующее критериям нормализации, 
обычно проводимое с целью ускорения операций чтения 
из базы за счет добавления избыточных данных. 

### Что такое запрос

Запрос (QUERY) - Обращение к базе данных написанное на языке SQL которое преднозначено для
изменения/внесение/получение каких-то данных

#### Агрегатные функции

Агрегатные функции выполняют вычисления над значениями в наборе строк

- AVG:      находит среднее значение
- SUM:      находит сумму значений
- MIN:      находит наименьшее значение
- MAX:      находит наибольшее значение
- COUNT:    находит количество строк в запросе

#### HAVING vs WHERE

Having и Where по сути выполняют одно и тоже действие - поиск

Having:
- Having может использоваться на первом месте запроса вместо where
даже в группе запросов (having A > 0 and B < 0)
- Having может использовать агрегатные функции having max(A) > 1;

Но есть очень важный момент использования Having.
При запросе с группировкой, мы можем использовать дополнительное условие выборки
после группировки только при помощи having

Пример:

    SELECT * FROM a 
        inner JOIN b 
        on a.id = b.b_id
        where a.A > 200
        group by b.id
        having a.C > 2
        
#### GROUP BY vs DISTINCT vs ORDER BY

GROUP BY -> группирует значения
DISTINCT -> выводит уникальные неповторяющиеся значения
ORDER BY -> выводит в порядке (деф возрастания) значения в таблице

Главное различие GROUP BY и DISTINCT, в синтаксисе описания

Пример для DISTINCT: 

    SELECT DISTINCT A, B
    FROM Table
    ORDER BY A;

Пример для GROUP BY:

    SELECT *
    FROM Table
    GROUP BY A, B;
    
(+ GROUP BY может работать с атомарными операторами из-за 
    того что находится в последней части запроса)
    
Когда нужен вывод чего-то одного без каких-то дополнительных полей - юзай DISTINCT
Нужна группировка значений воедино, но при этом оставить все левые - юзай GROUP BY

#### как GROUP BY обрабатывает значение NULL

Как обычное поле где NULL значения считаются равными друг другу

#### PRIMARY vs UNIQUE

PRIMARY:
- В таблице может быть только одно поле с первичным ключом
- В некоторых СУБД оно не может быть NULL - например, MySQL добавляет NOT NULL
- Первичный ключ - это уникальный идентификатор ключа записи

UNIQUE:
- Может быть более одного уникального ключа в одной таблице
- Уникальный ключ может иметь значения NULL
- Нулл значения между собой не равны, потому UNIQUE может иметь много NULL полей

#### DELETE vs TRUNCATE vs DROP

DROP        - удаляет таблицы (удаление таблицы базы данных)
DELETE      - для удаления одной или нескольких строк в таблице (с применением условия)
TRUNCATE    - удаляет все строки из таблицы (работает быстрее чем DELETE, но нельзя вешать условия)

#### UNION/INTERSECT/EXCEPT

![alt-text](https://mypresentation.ru/documents_6/58e4477c9079ad489120ab8f10f87c26/img10.jpg)
 
INTERSECT (Общее от двух)
UNION     (Объединение двух)
EXCEPT    (Исключающее)
   	 
    SELECT *
    FROM Table
    INTERSECT/UNION/EXCEPT
    SELECT *
    FROM Table2;

(! В MySQL есть только UNION, вместо INTERSECT/EXCEPT используются where column IN/NOT IN)

#### EXISTS

Предикат EXISTS принимает значение TRUE, если подзапрос содержит любое количество строк, 
иначе его значение равно FALSE. Для NOT EXISTS все наоборот. 

#### PIVOT

Реляционные операторы PIVOT и UNPIVOT можно использовать для 
изменения возвращающего табличное значение выражения в другой таблице. 

=======
1   |10
2   |20
3   |30

Переворачивается в 

=1==2===3==
10  20  30

#### Типы JOIN'ов

![atler-text](https://www.techagilist.com/wp-content/uploads/2018/07/sql-joins.png)

#### LEFT JOIN vs RIGHT JOIN

В случае с соединением множеств, LJ описывает ситуацию, когда объединяется
Левая часть таблицы включающая или исключающая пересечения с 

Такая же ситуация с правой

### Подзапрос / Типы подзапросов

SQL подзапрос — это запрос, вложенный в другой запрос;

По типам запросы используются в:
- В инструкции SELECT;
- В инструкции FROM;
- В условии WHERE.

### Соеденение vs подзапросы

**Подзапросы:**
преимущество относительно соединений, когда вам нужно быстро вычислять агрегатные значения 
и использовать их во внешних запросах для выполнения сравнения.

SELECT * FROM table WHERE some = (SELECT min(some) FROM table);

**Соединения**

Соединения имеют преимущества над подзапросами, 
если список выбора select в запросе содержит столбцы более чем из одной таблицы

### Функции ранжирования

**Ранжирующие функции** — это функции, которые возвращают значение для каждой строки группы в 
результирующем наборе данных. 
На практике они могут быть использованы, например, для простой нумерации списка, 
составления рейтинга или постраничной выборки.

Результирующие функции:
- **ROW_NUMBER**() OVER ([ORDER BY столбы группировки]) as [Имя полученной колонки]
    Выводит номер получившейся стоки
- **RANK**() OVER (order by column) [RANK] 
    возвращает ранг каждой строки. В отличие от row_number(), 
    идет уже анализ значений и в случае нахождения одинаковых, функция возвращает одинаковый ранг 
    с пропуском следующего.
    (Если найдет одинаковые значения то выведет 1.2.2.2.5.6.7)
- **DENSE_RANK** over (order by column) [DENSE_RANK]
    возвращает ранг каждой строки, но в отличие от rank, 
    в случае нахождения одинаковых значений, возвращает ранг без пропуска следующего.
    (Если найдет одинаковые значения то выведет 1.2.2.2.3.4.4)
- **NTILE**(3)over (order by price desc) [NTILE]
    функция Transact-SQL, которая делит результирующий набор 
    на группы по определенному столбцу. Количество групп указывается в качестве параметра.

### Выбор четных нечетных записей

Используя функцию mod

SELECT * FROM Persons WHERE MOD(PersonId, 2) = 1

### Первые 3 символа из строки

SELECT LEFT('String', 3)
SUBSTRING(str String, pos 0, len 3)

### Хранимые процедуры

Хранимые процедуры представляет набор инструкций, которые выполняются как единое целое. 
Тем самым хранимые процедуры позволяют упростить комплексные операции 
и вынести их в единый объект.

Каждая процедура описывается с помощью BEGIN и END 

Пример:
    
    CREATE PROCEDURE procedure AS
    BEGIN
        SELECT *
        FROM table
    END;

Чтобы вызвать хранимую процедуру используется команда **EXEC** или **EXECUTE**

#### Плюсы и минусы хранимых процедур

+ Скорость
+ Логика 
+ Код проще 
+ Безопасность (она уже скомпилирована) 
+ Защита приложния от изменения структуры
+ Процедуры не наш скоуп ответсвеннсти  

- Сложность переезда 
- Проблема SQL (жесткая привязанность)
    
### Триггеры

Триггеры представляют специальный тип хранимой процедуры, 
которая вызывается автоматически при выполнении определенного действия над таблицей 
или представлением, в частности, при добавлении, изменении или удалении данных, 
то есть при выполнении команд INSERT, UPDATE, DELETE.

    CREATE TRIGGER имя_триггера
    ON {имя_таблицы | имя_представления}
    {AFTER | INSTEAD OF} [INSERT | UPDATE | DELETE]
    AS выражения_sql
    
(В mySQL есть before но нет INSTEAD OF)

Использование:
    - добавление процента на товар
    - валидация
    
### Курсоры

Простыми словами курсоры это forEach по результату выборки

Для того чтобы использовать курсор его надо определить

    --объявляем курсор
    DECLARE my_cur CURSOR FOR 
     SELECT number, pole1, pole2 
     FROM test_table_vrem 
   
    --открываем курсор
    OPEN my_cur
    --считываем данные первой строки в наши переменные
    FETCH NEXT FROM my_cur INTO @number, @pole1, @pole2   
    WHILE @@FETCH_STATUS = 0
    BEGIN
        --на каждую итерацию цикла запускаем нашу основную процедуру с нужными параметрами   
        exec dbo.my_proc_test @number, @pole1, @pole2
        --считываем следующую строку курсора
        FETCH NEXT FROM my_cur INTO @number, @pole1, @pole2
    END
    --закрываем курсор
    CLOSE my_cur

