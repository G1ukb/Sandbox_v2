# Тестирование

![](https://elearn.epam.com/assets/courseware/v1/410860fdf29f9661f24af61a730de38d/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/The_High_Cost_of_Bugs_Tools_1.png)

## Делится по целям:
- **Функциональное** тестирования
(обеспечения качества тестирования функции методом черного ящика)
    - **По подходам** (Регрессивное или доменное)
        - зависит от основной области создания тестов
    - **По уровням** (Smoke or Critical)
        - сколько тестов нам нужно и насколько глубоко мы пойдем.
    - **По типам** (Совместимость or Usability)
        - какие конкретные тесты мы выберем для решения некоторых возможных проблем
    - **По дисциплинам** (Ручной или автоматический)
        - сравнение ручного и автоматического управления по ряду параметров
- **Нефункциональное** тестирование 
(широкий спектр внешних тестов событий, которые каким-то образом повлияют на наше приложение).
    **Делятся на:**
    - производительность
    - безопасность
    - надежность
    - ремонтопригодность
    - юзабилити
    - возможность поддержки

## По степени автоматизации:
- **Автоматического тестирование**
(Программное обеспечение для автоматической проверки кода проверяет исходный код 
на соответствие заранее определенному набору правил или передовым практикам. 
Программа или инструмент проверки обычно отображает список предупреждений, 
которые являются нарушениями предопределенных стандартов программирования.)
    - Проверяет исходный код на соответствие правилам или практикам
    - Локальная (само)проверка кода
    - Моментальная проверка
- **Мануальное тестирование**
(Экспертные обзоры или ручные проверки кода состоят из построчного чтения 
исходного кода с целью выявления потенциальных проблем.)
    - Возможность избежать ошибок проектирования
    - Возможность обучения и обмена знаниями для членов команды:
    
### Автоматического тестирование

Автоматизация тестирования - важная часть жизненного цикла разработки программного обеспечения

Метрики автоматизации тестирования:
- **окупаемость инвестиций (ROI)**.
![](https://elearn.epam.com/assets/courseware/v1/f331b444beb13eae406ff8cfe5940dbf/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/Test_automation_metrics__ROI__1_.svg)
- **охват**
![](https://elearn.epam.com/assets/courseware/v1/4a71494e3423095ceeb666113bc48b37/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/Group.svg)
- **приоритет**
![](https://elearn.epam.com/assets/courseware/v1/57aeaabf306f279a8af02a99808068ee/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/Test_automation_metrics__Coverage.svg)
    Есть четыре квадрата:
    1. высокий приоритет, низкая стоимость автоматизации;
    2. высокий приоритет, высокая стоимость;
    3. низкий приоритет, низкая стоимость;
    4. низкий приоритет, высокая стоимость.

Автоматизация может сэкономить время и деньги при правильном использовании, 
но для максимальной экономии затрат на тестирование вам необходимо найти 
правильный баланс между ручным и автоматическим тестированием.

### Мануальное тестирование

**Плюсы:**
- Более низкая стоимость на ранних этапах
- Каждое выполнение немного отличается - имеет определенную случайность
- Легко адаптируется к изменениям среды
- Гибкость
- Может поддерживаться инструментами
- Может обнаруживать небольшие изменения, недоступные инструментам, поскольку не смотрит на них
- Быстрое исполнение - быстрая обратная связь

**Минусы:**
- Кропотливая работа
- Некоторые задачи сложно выполнить вручную
- Может быть однообразным и скучным
- Менее точны, чем автоматические тесты

**Лучше подходит для:**
- Юзабилити тестирования
- Исследования проделанной работы
- Тестирования доступность
    

## По позитивности сценария:
- **Позитивным** – проверка ПО на соответствие ожидаемому поведению. 
Основная задача тестирования – проверить, корректно ли работает программа.
- **Негативным** – проверяет, будет ли ПО работать в случае, 
когда поведение пользователя отличается от ожидаемого.

## По доступу к коду
- **Тестирование «белого ящика»** – тестирование программного продукта с доступом к коду.
- **Тестирование «черного ящика»** – тестирование без доступа к коду продукта.
- **Тестирование «серого ящика»** – тестирование, основанное на ограниченном знании внутренней структуры. 
В данном случае тестировщик не работает с кодом программного продукта, 
но он знаком с внутренней структурой программы и взаимодействием между компонентами.

### Черный ящик 

При тестировании **черного ящика** мы не имеем представления об устройстве системы. 
Тестируя **что программа делает**, а не как она это делает.

Преимущества:
- тестирование производится с позиции конечного пользователя и может помочь 
обнаружить неточности и противоречия в спецификации;
- тестировщику нет необходимости знать языки программирования или логики работы;
– тестирование может производиться разными специалистами
– можно начинать писать тест-кейсы, как только готова спецификация.

Недостатки:
– тестируется только очень ограниченное количество путей выполнения программы;
– без четкой спецификации достаточно трудно составить эффективные тест-кейсы;
– некоторые тесты могут оказаться избыточными;

### Белый ящик

При тестировании **белого ящика** мы сравниваем 
фактический результат выполнения программы с ожидаемым
полностью зная то, как работает система

Преимущества:

– тестирование может производиться на ранних этапах;
– достаточно тщательно покрывает код программы.

Недостатки:
– для выполнения тестирования белого ящика необходимо большое количество специальных знаний
– большой уровень расходов, если программа часто изменяется.

### Серый ящик

**Серый ящик** - Нам известны только некоторые особенности реализации тестируемой системы.

## По уровню тестирования
- **Модульное / Unit-тестирование** – проверка корректной работы отдельных модулей проекта. 
Этот вид тестирования могут выполнять сами разработчики.
    - Проверка отдельного класса
    - Проверить правильность и работоспособность кода
    - Сверяет удовлетворение бизнес требованиям.
    - Обеспечивает лучшее качество, но не улавливает все ошибки в программе  
- **Интеграционное тестирование** – проверка взаимодействия между несколькими модулями проекта.
- **Системное** – проверка работы всей системы на соответствие заявленным требованиям к 
программному продукту.
- **Функциональное** - эмулирование поведения конечного пользователя системы.
- **Smoke тестирование** - очень небольшие тесты, которые прогоняются перед запуском системы
чтобы удостоверится в ее работоспособности.
- **Regression test** - тест эмулирующий поведение реальной ошибки
- **Acceptance test** - тест на соответствие 
- **Penetration test** - Проверка системы на различные уязвимости.
- **Fuzzing test** - Идея заключается в подаче на вход системы случайного, 
заведомо некорректного или неожиданного входного потока данных.

### Unit тестирование

Проверка того что код работает должным образом. 
Среди важных качеств модульного теста можно выделить следующие:

- Проверяет работоспособность мельчайших элементов приложения
- Написано разработчиками
- Легко запустить в IDE
- Работает относительно быстро
- Легко интегрируется с CI (непрерывной интеграцией)

**Почему Unit tests**
- Исправление/Обнаружение деффектов по мере разработки
- Поддержка проекта в необходимом состоянии

Если вы работаете без модульных тестов, вы начнете тратить время на попытки понять, 
как работает старый код, и убедиться, что ваше изменение не нарушило его.

![](https://elearn.epam.com/assets/courseware/v1/b29602660b52e306c851053d644af883/asset-v1:EPAM+EngXBootcamp+2020+type@asset+block/Unit_testing___why_.svg)

**Принципы Unit тестирования:**
Они описываются правилом **F.I.R.S.T.**
- **Fast** - тесты должны быть быстрыми.
Когда тесты выполняются медленно, вы не хотите запускать их часто. 
И если вы не запускаете их часто, вы не обнаружите проблемы достаточно рано, 
чтобы их легко исправить.
- **Independent (или Isolated)** - тесты не должны зависеть друг от друга. 
Один тест не должен устанавливать условия для следующего теста. Чтобы не вызвать каскада падений
- **Repeatable** - тесты должны быть повторяемыми в любой среде. 
Результаты тестирования должны быть одинаковыми всегда и в любом месте.
- **Self-validating** - тесты должны иметь логический вывод. Они либо проходят, либо нет.
В случае отказа, вам не нужно бегать по лог файлам и искать причину ошибки.
- **Своевременность** - тесты должны быть написаны своевременно, 
непосредственно перед производственным кодом.

### Интеграционное тестирование

**Интеграционное тестирование** - одна из фаз тестирования, при которой 
**отдельные программные модули объединяются и тестируются в группе**. 

Целью интеграционного тестирования является проверка соответствия 
разработки   функциональным, приёмным и требованиям надежности.

Пример: Обработчики HTTP-запросов, должны тестировать также, 
как будет пользоваться конечный клиент этого самого сервиса. 
Это означает, что фактически, для таких тестов необходимо 
воссоздать почти полноценно работающее окружение.

Существует несколько **подходов** к интеграционному тестированию:
- Снизу вверх. Сначала тестируются модули самих нижних уровней, а затем по возрастанию к вершине иерархии. 
- Сверху вниз. Сначала тестируются модули самих высоких уровней, а затем по убыванию используя заглушки. 
- Большой взрыв. Все модули всех уровней собираются воедино, а затем тестируется.

Преимущества:
- обеспечивает сборку программной системы при проведении тестов.
- проверяет соответствие требованиям со стороны пользователя.
- интеграционное тестирование необходимо для проверки того, работают ли программные модули как единое целое.

### Системное тестирование

**Системное тестирование** - одна из фаз тестирования, проводится 
**проверка системы в целом** с целью выявления диффектов

Это комплексный тест, который тестирует связку сразу нескольких компонентов. 
Система в этом случае воспринимается как черный ящик.

### Функциональный тест

Тест, который призван полностью эмулировать поведение конечного пользователя системы. 
Фактически вы должны написать робота, который будет пользоваться вашей системой в тестовом окружении. 
Чаще этот термин используется применительно к GUI, т.е. 
взаимодействие пользователя и графического интерфейса системы.

### Smoke тестирование

Это частный случай интеграционного теста. 
Обычно это очень небольшие тесты, которые прогоняются перед запуском системы, 
чтобы убедиться в работоспособности стороннего ПО, которое необходимо для корректного функционирования нашей системы. 
В случае провала таких тестов, мы можем оповестить пользователя о проблеме или и вовсе остановить запуск системы.

Такие тесты еще часто называют дымовыми.
Дымовое тестирование — пришло из сферы проверки оборудования, 
если, после подачи питания, появляется дым и запах гари, то оборудование неисправно.

### Regression test

Это может быть любой вид теста из описанных выше, который пишется после того, 
как была обнаружена проблема. 
Тест должен эмулировать в точности шаги для воспроизведения проблемы. 
Наличие такого теста после исправления проблемы дает гарантию, 
что точно такой же баг, больше не появится в системе.

### Penetration test

Проверка системы на различные уязвимости. 
Хорошим примером будут тесты проверяющие экранирование SQL-команд (защита от инъекций), 
доступность данных и авторизацию с истекшим токеном и т.д. 
Сложность в написании таких тестов — это учет всех узких мест. 
Обычно для этого используют публичную информацию об известных уязвимостях 
и эксплоитах используемой платформы.

### Fuzzing test

Чаще разновидность системного теста или проверки на уязвимость. 
Идея заключается в подаче на вход системы случайного, 
заведомо некорректного или неожиданного входного потока данных. 
Целью такого теста является попытка обнаружить нарушения логики валидации и верификации, 
логики приложения в граничных случаях, внезапные падения сервера, 
попытки выявить утечки памяти или утечки информации о внутреннем устройстве системы, 
через необработанные сообщения об ошибках (stacktrace)

### Acceptance test

Это может быть любой вид теста из описанных выше, который пишется после того, 
как была обнаружена проблема. 
Тест должен эмулировать в точности шаги для воспроизведения проблемы. 
Наличие такого теста после исправления проблемы дает гарантию, 
что точно такой же баг, больше не появится в системе.

## По моделям разработки делятся на:
- Классическую разработку
- Разработку через тестирование  

# Пирамида тестирования

«Пирамида тестов» — абстракция, которая означает группировку тестов по разным уровням детализации.
Она также даёт представление, сколько тестов должно быть в каждой из этих групп

Из этой пирамиды следует два **принципа**:
- Писать тесты разной детализации.
- Чем выше уровень, тем меньше тестов.

**Уровни:**
- **Модульные тесты** - очень быстрые - тысячи тестов могут быть выполнены всего за несколько минут. 
    - они более стабильны (правило FIRST)
    - помогают задуматься о возможных местах ошибок
    - помогают найти ошибки на более ранних этапах
    - быстрое время выполнения - быстрый фидбэк
    - независимость на пользовательский интерфейс, бд или api
    - просто пишутся и легко поддерживаются
- **Интеграционные тесты** - Тестирование API проводят, основываясь на бизнес-логике программного продукта. 
    - используются для проверки нескольких взаимосвзаных модулей
    - используются для проверки выполнения бизнес-логики
    - избавлены сложностями использования UI (postman дергает рест)
    - нужно настраивать систему подобную к реальной из-за чего тесты дороже
- **UI тесты** - Выполнение одного теста пользовательского интерфейса может занять два часа, 
а выполнение - две минуты.
    - проверка корректности работы UI
    - проверяет бизнес-логику с точки зрения пользователя
    - Тесты пользовательского интерфейса медленнее и тяжелее в написании и поддержке, 
    поэтому необходимо сводить их к минимуму.

![](https://qastart.by/images/Pyramid_API.png)  

# Тестирование и разработка ПО   
   
## Разработка через тестирование

1. При разработке через тестирование каждая новая функция **начинается с написания теста**. 
Чтобы написать тест, разработчик должен четко понимать спецификации и требования функции.

2. На втором этапе **запустите все тесты** и посмотрите, не сработает ли новый тест.

3. **Написание кода, который приведет к прохождению теста.** 
Новый код, написанный на этом этапе, несовершенен. 
На этом этапе **единственная цель** написанного кода - пройти тест. 
Программист не должен писать код, выходящий за рамки проверяемых тестом функций.
(Может откинуть на части 1-2)

4. **Поверка что все тесты прошли проверку** (может перекинуть на части 1-3)

5. Повторять пока все тесты не будут проходить и не появится новых требований.
После этого следует стадия **код рефактора**.

## Классическая модель разработки

Сначала разработка, потом тестирование. 
Это означает, что сначала происходит разработка, 
затем продукт тестируется и отправляется, или начинается следующий этап разработки.

# Testing tools

- JUnit
- Mockito
- Matcher libs: FEST and Hamcrest
- JUnitParams
- EasyTest
- Code coverege: cobertura
- Power spring.Mock and EasyMock
- Utilities: Catch-Exeption Unitils
- Build tools: Gradle and Maven

# Тестирование взаимодействий

ТЕСТИРОВАНИЕ ВЗАИМОДЕЙСТВИЯ - это тип тестирования, при котором проверяется, 
может ли программное обеспечение взаимодействовать с другими программными компонентами и системами
без каких-либо проблем совместимости.

Обеспечивает соответствие продукта требованиям стандарта и спецификации.

Например, между смартфонами и планшетами проводится тестирование совместимости 
для проверки передачи данных через Bluetooth.

**Виды совместимости:**
- Физическая совместимость
- Совместимость типов данных
- Уровень совместимости спецификации
- Семантическая совместимость

Тестирование совместимости проводится, потому что,
- Он обеспечивает комплексное предоставление услуг для двух или более продуктов от разных поставщиков.
- Программный продукт должен иметь возможность взаимодействовать с другим компонентом 
или устройством без каких-либо проблем совместимости.

**Риск, связанный с отсутствием тестирования на совместимость:**
- Потеря данных
- Ненадежная работа
- Неправильная работа
- Низкая ремонтопригодность

**Недостатки тестирования совместимости:**
- Определение первопричин дефектов
- Точное измерение
- Масштабируемость тестирования
- Сложность сети
- Тестирование испытательного оборудования
- Документирование результатов тестирования и обучения
- Неадекватные требования

# Mocks. Mockito.

Mocks (фиктивные объекты) - это смоделированные объекты, которые имитируют поведение 
реальных объектов управляемыми способами. 
Программист обычно создает имитацию объекта, чтобы проверить поведение какого-либо другого объекта.

В модульном тесте фиктивные объекты могут имитировать поведение сложных реальных объектов и поэтому полезны,
когда реальный объект непрактично или невозможно включить в модульный тест. 

характеристики объектов, которые стоит делать фиктивными:
- объект предоставляет неопределенные результаты (дата)
- в нем есть состояния, которые сложно создать или воспроизвести руками (сетевая ошибка)
- он медленный (например, бд которую нужно было бы инициализировать перед тестом);
- он еще не существует или может изменить поведение;
- он должен работать изолированно от остальной программы (будильник который вызываем самолично)

## Mockito

Наиболее часто используемая аннотация в Mockito - это @spring.Mock. 
Мы можем использовать @spring.Mock для создания и внедрения моков 
без необходимости вручную вызывать Mockito.mock.

Полученному моку мы можем:
- Определить поведение - when(mock).thenReturn(value)
- Подсчетать количество вызовов - atLeast, atLeastOnce, atMost, times, never
- Определить обработку исключений - when(mock).thenThrow()
- Использование интерфейса org.mockito.stubbing.Answer<T> для проверки сложный условий
- Проверка вызова метода с задержкой, timeout

spy () / @ Spy: частичный мок объекта, 
вызываются реальные методы, но их все еще можно проверить и заглушить

@InjectMocks: автоматически проинициализировать объект и внедрить в него 
объекты которые аннотированны как @Spy или @spring.Mock

@InjectMocks используется для:
- создания экземпляров класса, которые необходимо протестировать в тестовом классе.
- когда необходимо выполнить конструктор данного класса.
- когда нам нужно, чтобы все внутренние зависимости были инициализированы 
с помощью фиктивных объектов для правильной работы метода.

# Spring Testing

Юниты работают точно так же как и надо.
В интеграционных тестах у нас появляется возможность поднять контекст
@RunWith(SpringRunner.class)
Может поднимать какой-то внутренний сервер тестирования
Имеет возможность встраивать моки и спаи в @MockBean


