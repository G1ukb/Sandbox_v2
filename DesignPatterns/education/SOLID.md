<h1>SOLID</h1> 
<h4> 

[Back to menu](..%2FDP_Menu.md)

</h4>

#SOLID

## Для чего нужны принципы SOLID

Для обеспечения стратегии гибкой и адаптивной разработки проекта.

При разработке проекта использование принципов SOLID
способствует созданию такой системы, которую будет легко
поддерживаться и расширяться в течение долгого времени.

Принципы SOLID — это руководства, которые также могут применяться
во время работы над существующим проектом для его улучшения,
например, для удаления «плохого» кода.

## Каковы принципы SOLID

- S - Single Responsibility Principle (Принцип единственной ответственности)
- O - Open Close Principle  (Принцип открытости/закрытости)
- L - Liskov Substitution Principle (Принцип подстановки Лисков)
- I - Interface Segregation Principle (Принцип разделения интерфейса)
- D - Dependency Inversion Principle (Принцип инверсии зависимостей)

## Подробнее о каждом принципе (какую проблему он старается решить)

### Single Responsibility Principle (Принцип единственной ответственности)

**Определение: У модуля есть один и только один повод для изменения.**
**Класс должен быть ответственен лишь за что-то одно.**

Потенциально можно словить ошибку при добавлении нового функционала
Потенциально усложняет класс делая его монолитным
Тестирование такого класса усложняется.

**Какую проблему решает**
- Решает проблему божественных классов
- Решает проблему когда объекту дозволяется слишком много

**Типовые примеры нарушения**:
- смешивание слоев архитектуры приложения
    - Слой представления (UI или Web page)
    - Сервисный слой (контроллеры, веб-сервисы и слушатели очередей)
    - Слой бизнес-логики (обрабатывают запросы сервисного слоя и используют слой доступа к данным)
    - Слой доступа к данным (доступа к хранимым данным)

### Open Close Principle  (Принцип открытости/закрытости)

**Определение: Классы должны быть открыты для расширения, но закрыты для изменения**

**Какую проблему решает**
Добавление общего функционала в один класс может сделать его монолитным.
Так же как и в S принципе, вместо создания монолитного класса следует делать его
наследников, которые будут расширять базовый класс.

**Открыты для расширения.**
Мы можем добавить модулю новое поведение в соответствии
с изменившимися требованиями к приложению или для удовлетворения нужд новых приложений.
Не трогая при этом точки использования базового класса, исключая возможности ошибок в них.

**Закрыты для изменений.**
Исходный код такого модуля неприкасаемый.
Никто не вправе вносить в него изменения. Кроме изменений в бизнес логики

**Типовые примеры нарушения**:
- класс монолит в котором перемешаны архитектурные слои
- множественный иф оператор (поскольку добавление нового условия изменит базовый класс,
  как решение - запихнуть его в класс обстракцию и вызывать передавая параметры)

### Liskov Substitution Principle (Принцип подстановки Лисков)

**Определение: Наследник класса дополняет, но не заменяет поведение базового класса**:
**В любом месте программы замена базового класса на класс-наследник не должна вызывать проблем.**

**Решает проблему**
Соблюдение принципа подстановки Барбары Лисков позволяет гарантировать,
что любой созданный нами подкласс будет без проблем использоваться ранее реализованными модулями

**Типовые примеры нарушения**:
- переопределяющий класс нарушает логику базового. При замене выбивается ошибка
- явное приведение типов (Если вам нужно привести объект к какому-либо типу,
  вы не используете базовый класс без знания производных классов)

### Interface Segregation Principle (Принцип разделения интерфейса)

**Определение: Программные сущности не должны зависеть от методов, которые они не используют.**
**Слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические**

Как плюс, в случае изменения метода в интерфесе, все классы его реализующие будет легче
перестроить, если этот интерфейс достаточно мал и используется в специфическом месте.

NonSupportedException

### Dependency Inversion Principle (Принцип инверсии зависимостей)

**Определение:
Модули верхних уровней не должны зависеть от модулей нижних уровней.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций**

**Какие проблемы решает**
- Избавляет жесткую зависимость между компонентами приложения
  (говорит нам, что все должно быть зависимо от абстракций)

Если модули жестко связаны -
- Изменение одного модуля ведет к изменению других модулей
- Изменения приводят к неконтролируемым ошибкам в других частях программы.
- Модуль сложно отделить от остальной части приложения для повторного использования.

