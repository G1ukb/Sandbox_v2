[//]:# (Java Fundamentals)

<details>
    <summary>
        <b><big><big><big>
            Java Fundamentals
        </big></big></big></b>
    </summary>

<br>
<details>
    <summary>
        <b><big><big>
            Принципы ООП
        </big></big></b>
    </summary>

- **Инкапсуляция** (Свойство отношения одного объекта системы с другим объектом системы)
  - **Наследование** (Свойство расширения родительского(базового) класса наследниками)
  - **Полиморфизм** (Свойство одних из тех же объектов выполнять одинаковый функционал по разному)
  - **Абстракция** (Свойсвто вычленения из объекта только необходимых нам параметров)

</details>
<br>

[//]:# (Перегрузка и переопределение)

<details>
    <summary>
        <b><big><big>
            Перегрузка и переопределение
            Сигнатура перегрузки
        </big></big></b>
    </summary>

Когда два или более метода в одном классе имеют одно и то же имя,
но разные параметры, это называется перегрузкой.
Перегрузкой считается условие когда изменена сигнатура метода (имя и параметры)

Переопределение это ситуация когда дочерний класс переопределяет метод
(объявляет метод с тем же именем и входными параметрами и возвращаемым значением)
но пишет этому методы собственное поведение
(так же если мы имплементируем метод)

</details>
<br>

[//]:# (Полностью ли Java OOP)

<details>
    <summary>
        <b><big><big>
         Полностью ли Java OOP
        </big></big></b>
    </summary>

Нет, поскольку джава содержит примитивы, а они в свою очередь не являются объектами

</details>
<br>

[//]:# (Примитивы и Ссылочные типы данных)

<details>
    <summary>
        <b><big><big>
         Примитивы и Ссылочные типы данных
        </big></big></b>
    </summary>

**Ссылочные** типы данных нужны нам как объекты трансферы они хранят и
обмениваются значением

Преимущества ссылок:

* **могут быть пустыми**
  * **ссылочный тип данных может копировать ссылку obj = anotherObj();**

**Примитивные** типы данных представляют собой одиночные значения, хранящиеся в памяти.

Примитивные типы данных:

* byte short int long
  * float double
  * boolean
  * char

**(с компилятором они работают намного быстрее за счет устройства памяти и JVM)**

</details>
<br>

[//]:# (Изменение значения примитива, поля, ссылочного типа при передаче в метод)

<details>
    <summary>
        <b><big><big>
         Изменение значения примитива, поля, ссылочного типа при передаче в метод
        </big></big></b>
    </summary>

Все изменяется по значению. Даже когда передается объект,
на самом деле передается значение ссылки на
область в памяти где этот объект хранится.

</details>
<br>

<details>
    <summary>
        <b><big><big>
         Конструкторы (+ блоки инициализации)
        </big></big></b>
    </summary>

**Конструктор** - это метод предназначенный для инициализации экземпляра класса.
Конструктор есть в каждом классе! Если он не объявлен явно,
он будет предоставлен по умолчанию.

- По умолчанию
  - С параметрами
  - Копирования (входным параметром является объект того же класса)

**Блоки инициализации**:
Бывают статические и не статические
В целом блоки инициализации присутсвуют в джаве чтобы инициализировать переменную до срабатывания
конструктора

</details>
<br>

[//]:# (В каком порядке инициализируются)

<details>
    <summary>
        <b><big><big>
         В каком порядке инициализируются
        </big></big></b>
    </summary>

Статика
Статический блок инита
Статический конструктор
Статические поля
Потом обычные инстанс
блок инита
конструктор
поля

</details>
<br>

<details>
    <summary>
        <b><big><big>
         Может ли статический конструктор инициализировать обычные поля (Нет)
        </big></big></b>
    </summary>

Нет, напрямую
Да, если создаст объект руками

</details>
<br>

[//]:# (Может ли описываться блок инициализации, если в классе вообще ничего нет кроме конструктора (Зачем?)

<details>
    <summary>
        <b><big><big>
         Может ли описываться блок инициализации, если в классе вообще ничего нет кроме конструктора (Зачем?)
        </big></big></b>
    </summary>
Да

(Зачем?)
Для логирования
</details>
<br>

[//]:# (Типы классов Java)

<details>
    <summary>
        <b><big><big>
         Типы классов Java
        </big></big></b>
    </summary>
Интерфейс - Абстрактный класс - Обычный класс - Enum

![img](https://dan-it.gitlab.io/fs-book/java-basic/collections/img/inner_classes.png)
</details>
<br>

[//]:# (Модификаторы класса, метода, поля, доступа)

<details>
    <summary>
        <b><big><big>
         Модификаторы класса, метода, поля, доступа
        </big></big></b>
    </summary>

**Доступа**
В Java используются следующие модификаторы доступа:

- **public**: публичный, общедоступный класс или член класса.
  - **private**: закрытый класс или член класса, противоположность модификатору public.
  - **protected**: такой класс или член класса доступен из любого места в текущем классе или пакете
  - **package private**. Такие поля или методы видны всем классам в текущем пакете.

**В контексте класса**
В контексте класса используются модификаторы abstract, final, static

**В контексте методов**
Методы в Java могут быть объявлены как abstract, final, static, native, synchronized.

Модификатор **native** перед объявлением метода указывает, что он явялется специфическим
для операционной системы. Как и у абстрактного метода, у него тоже нет тела,
а реализация находится в скомпилированном виде в файлах JVM.

Модификатор **synchronized** у метода говорит о том, что перед его выполнением должен быть
захвачен монитор объекта (для нестатического метода), либо монитор,
связанный с классом (для статического метода).

**В контексте Полей**
Они могут быть описаны с такими модификаторами как static, final, transient, volatile.

Для указания того, что во время сериализации объекта некоторое поле нужно игнорировать,
используется модификатор **transient**

С модификатором **volatile** все немного посложнее. Гарантия значения из памяти.


</details>
<br>

[//]:# (Object.class)

<details>
    <summary>
        <b><big><big>
         Object.class
        </big></big></b>
    </summary>

Фактически все классы наследуются от класса Object.
И класс Object необходим, для того чтобы иметь возможность с этими объектами работать.

Для работы с объектами:

- toString
  - hashCode - По-умолчанию - целочисленный адрес в памяти
  - equals - возвращает результат сравнения двх объектов
  - getClass - получить класс объекта во время выполнения.
  - finalize - помечает объект для очистки GC
  - clone - метод неглубокого копирования

Работа в мультипотоке

- notify
  - wait
  - notify all

</details>
<br>

[//]:# (Как работает clone?)
<details>
    <summary>
        <b><big><big>
         Как работает clone?
        </big></big></b>
    </summary>

Реализация по умолчанию Object.clone() метод **возвращает Неглубокое копирование**.

**При неглубоком копировании**, если значение поля является примитивным типом,
оно копирует свое значение; в противном случае,
если значение поля является ссылкой на объект, оно копирует ссылку и,
следовательно, ссылается на тот же объект.
</details>
<br>

[//]:# (Правила переопрделения hashcode и equals)

<details>
    <summary>
        <b><big><big>
         Правила переопрделения hashcode и equals
        </big></big></b>
    </summary>

**Рефлексивность:** Объект должен равняться себе самому.

**Симметричность:** если a.equals(b) возвращает true, то b.equals(a) должен тоже вернуть true.

**Транзитивность:** если a.equals(b) возвращает true и b.equals(c) тоже возвращает true, то c.equals(a)
тоже должен возвращать true.

**Согласованность:** повторный вызов метода equals() должен возвращать одно
и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено.
То есть, если два объекта равны в Java, то они будут равны пока их свойства остаются неизменными.

**Сравнение null**: объект должны быть проверен на null.
Если объект равен null, то метод должен вернуть false, а не NullPointerException.
Например, a.equals(null) должен вернуть false.

</details>
<br>

[//]:# (Class.class)

<details>
    <summary>
        <b><big><big>
         Class.class
        </big></big></b>
    </summary>

Изначально описанный в классе шаблон трансформируясь в байткод выглядит как набор
массивов который содержит большое число данных.
Кто загрузил, какие филды + кол-во, какие конструкторы + кол-во,
пакет, родитель, интерфейсы.

* getSuperclass()
  * getPackage()
  * getMethods()
  * getInterfaces()

**java.lang.Class** представляет методы для получения этих данных
(в качестве способа применения - рефлексия)
так же предоставлены методы для определения типа класса

* isPrimitive()
  * isLocalClass()
  * isInterface()
  * isInstance(Object obj)
  * isEnum()
  * isAssignableFrom(Class<?> cls)
  * isAnonymousClass()

</details>
<br>

<details>
    <summary>
        <b><big><big>
         Immutable object
        </big></big></b>
    </summary>

Неизменяемый объект — это объект, внутреннее 
состояние которого остается постоянным после того, как он был полностью создан.

Это означает, что публичный API неизменяемого объекта гарантирует нам, 
что он будет вести себя одинаково в течение всей своей жизни.

Чтобы добиться этого используются следующие элементы:
* **final** - гарантирует неизменяемость ссылки, но не значения
* В случае если неизменяемый объект хранит в себе ссылки на другие объекты 
позаботьтесь о том, чтобы и его поля были final, и он не имел возможность поменять
свое значение из вне. Например закрыв доступы к сетерам и наполняя поля только 
один раз в конструкторе элемента.

Что дает нам Immutable object:
* мы можем спокойно делиться объектом во всем приложении
* он не имеет побочных эффектов изменения состояния

</details>
<br> 

<details>
    <summary>
        <b><big><big>
         String
        </big></big></b>
    </summary>

Строковый объект представляющий собой набор char элементов

2 способа создать

* с помощью **специализированного конструктора** ("123")
* с помощью создания **объекта new String**("123") 

При этом при создании будет создан объект, помещен в пулл строк 
а как результат нам вернется ссылка на объект в пулле строк

Пул строк Java: Пул строк Java относится к набору строк, 
которые хранятся в куче памяти. 
При этом всякий раз, когда создается новый объект, 
**пул строк сначала проверяет, присутствует ли этот объект в пуле или нет**.

**String объекты сами по себе immutable**. Это означает что строка является частью
массива строк и возвращает ссылку на новую строку при каждом изменении.
Поскольку при каждом изменении мы стараемся проверить весь пул строк на наличие
искомого слова, операция может быть крайне требовательная к перфомансу

Для того чтобы избежать этой проблемы были 
созданы **mutable StringBuffer и StringBuilder** 

Они являются stream ами строк позволяя манипулировать строкой выигрывая по перфомансу

При этом их двое для разделения на работу в многопоточной среде и нет.
**StringBuffer синхронизированный - а StringBuilder быстрее** 


</details>
<br>  

</details>
<br>

[//]:# (Nested classes)

<details>
    <summary>
        <b><big><big><big>
            Внутренние Вложенные классы (Nested)
        </big></big></big></b>
    </summary>

<br>
<details>
    <summary>
        <b><big><big>
         Nested class types
        </big></big></b>
    </summary>

* **Static nested** - статическая логика которая не зависит от инициализации объекта
* **Local internal** - логика, которая зависит от инициализации объекта.
  Оптимизируя логическую группировку и расширяя инкапсуляцию.
* **Anonymous internal** - упрощенная форма без создания и инициализации класса

Зачем оно нам:

* Способ логической группировки чтобы не захламлять пакет,
  способ предупредить программиста, что класс используется/принадлежит другому
* Увеличение инкапсуляции.
* Как результат мы можем получить более читаемый и чистый код.

![img](https://res.cloudinary.com/practicaldev/image/fetch/s--A1l3RUvp--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.mednikov.net/wp-content/uploads/2019/10/nested-classes-overview.png)
</details>
<br>

<details>
    <summary>
        <b><big><big>
          Когда какой тип класса использовать
        </big></big></b>
    </summary>

**Локальный класс:**

+ введение нового именованного типа данных
+ логическая группировка

**Анонимный класс:** если нужно использовать методы или проинициализировать
поля и при этом выполняемое действие служит только для 1 класса
и вынесение его даже как локального считается дорогим занятием

**Вложенный класс:** используйте его, если ваши требования аналогичны требованиям
локального класса, вы хотите сделать этот тип более доступным
и вам требуется доступ к локальным переменным или параметрам класса родителя.

**Статический вложенный:** для статических полей базового статического класса

+ возможность расширения инкапсуляции для других объектов системы

[Oracle link](https://docs.oracle.com/javase/tutorial/java/javaOO/whentouse.html)
</details>
<br>

</details>
<br>

[//]:# (Annotations)

<details>
    <summary>
        <b><big><big><big>
            Annotations
        </big></big></big></b>
    </summary>

<br>
<details>
    <summary>
        <b><big><big>
            Что такое и какая главная причина использования аннотаций?
         </big></big></b>
     </summary>

Аннотации представляют собой дескрипторы, включаемые в текст программы,
и используются для хранения метаданных программного кода,
необходимых на разных этапах жизненного цикла программы.

Информация, хранимая в аннотациях, может использоваться соответствующими
обработчиками для создания необходимых вспомогательных файлов
или для маркировки классов, полей и т.д.

</details>
<br>

<details>
    <summary>
        <b><big><big>
            Инструкции выполнения аннотаций (по типу выполнения)?
         </big></big></b>
     </summary>

Инструкция для компилятора (Compiler)
@Override
@SuppressWarnings
Инструкция во время построения (Build-time)
Инструкция во время запуска (Runtime)
@Deprecated

</details>
<br>

<details>
    <summary>
        <b><big><big>
            Какие типы объектов могут быть возвращены из объявления метода аннотации?
         </big></big></b>
     </summary>

Возвращаемый тип должен быть примитивом, Строкой , Классом,
Перечислением или массивом одного из предыдущих типов.

</details>
<br>

<details>
    <summary>
        <b><big><big>
            Как кастомные аннотации могут помочь в улучшении кода
         </big></big></b>
     </summary>

* Сократите усилия по написанию кода, добавив в методы поведение по умолчанию.
* Добавление пользовательского поведения в классы и интерфейсы
* Сэкономьте усилия на написании XML-дескрипторов и маркерных интерфейсов.

</details>
<br>

<details>
    <summary>
        <b><big><big>
         Краткий шаблон создания аннотации
         </big></big></b>
     </summary>

@Target(указываем тип)
@Retention(указываем способ работы) //SOURCE, CLASS и RUNTIME
</details>
<br>

<details>
    <summary>
        <b><big><big>
         Что такое мета аннотации 
         </big></big></b>
     </summary>

Мета аннотации, это аннотации расширяющие поведение уже созданных аннотаций
добавляется через аннотацию @inherit
</details>
<br>

</details>
<br>

[//]:# (Exeptions)

<details>
    <summary>
        <b><big><big><big>
            Exceptions
        </big></big></big></b>
    </summary>

<br>
<details>
    <summary>
        <b><big><big>
         Лучшие практики использования исключений
        </big></big></b>
    </summary>

- **Будьте осторожны, что вы регистрируете**
  Логи результата ошибки не должны содержать приватной информации
- **Неправильно отлавливать исключения и ничего с ними не делать**
- **Включайте глобальный обработчик исключений во избежание критической ситуации в
  важной для вас точке**
- **Не закрывайте ресурс руками**
- **Выбрасывайте раньше, отлавливайте позже**, это правило, для того чтобы покрыть
  как можно больше или отловить как можно раньше
- **Не логать и не пробрасывать**, не стоит пренебрегать возможным вбросом и логированием
- **Явно определите выбрасываемое исключение**. Чем уже, тем точнее
- **Сначала отлов узкого места потом широкого**

[infoLink](https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/Java-Exception-handling-best-practices)
</details>
<br>

</details>
<br>

[//]:# (Generics)

<details>
    <summary>
        <b><big><big><big>
            Generics
        </big></big></big></b>
    </summary>

[Usefully resource](https://convincedcoder.com/2018/09/29/Java-generics-wildcards-type-erasure/)

<details>
    <summary>
        <b><big><big>
            Что такое стирание типа и как оно работает
         </big></big></b>
     </summary>

При написании кода мы указываем дженерики разного рода, для того чтобы
сделать наши классы более масштабируемыми

А для того чтобы этот механизм корректно работал с точки зрения компиляции.
Компилятор преобразует дженерик тип в объект. Это называется стиранием типа.

    Как это работает
    public static  <E> boolean containsElement(E [] elements, E element){
    после компиляции выглядит как
    public static  boolean containsElement(Object [] elements, Object element){

</details>
<br>

<details>
    <summary>
        <b><big><big>
            Что такое бридж метод
         </big></big></b>
     </summary>

Скрытый механизм работы джава компилятора при которой он сам пытается исключить
ошибку подстановки типов
И для этого генерирует дополнительный метод работы с подстановочными методами

    Пример:
    public class MyComparator implements Comparator<Integer> {
    public int compare(Integer a, Integer b) {

    Компаратору явно задан тип, поэтому сравнивать два Object объекта будет не правильно

.

    Поэтому компилятор создаст бридж метод чтобы избежать проблему:

    public class MyComparator implements Comparator<Integer> {
    public int compare(Integer a, Integer b) {
    
    //THIS is a "bridge method"
    public int compare(Object a, Object b) {
    return compare((Integer)a, (Integer)b);

</details>
<br>

</details>
<br>

[//]:# (Collections)

<details>
    <summary>
        <b><big><big><big>
            Collections
        </big></big></big></b>
    </summary>

![img](https://data-flair.training/blogs/wp-content/uploads/sites/2/2018/03/hierarchy-of-collection-framework-in-java.webp)


<details>
    <summary>
        <b><big><big>
            Раскрыть базовый принцип работы базовых коллекций
         </big></big></b>
     </summary>

* **List**
* **ArrayList** - Классическая модель хранения, при которой выделяются ячейки памяти
* **LinkedList** - Модель хранения при которой все храниться в качестве листа который
  имеет ссылки на предыдущий и следующий элементы

* **Queue** (представлено связным списком)
* **PriorityQueue** - PriorityQueue основан на куче приоритетов.
  Элементы приоритетной очереди упорядочиваются в соответствии с
  естественным порядком или компаратором,
  предоставленным во время построения очереди
* **ArrayDeque** - особый тип массива, который растет и позволяет пользователям
  добавлять или удалять элементы с обеих сторон очереди.

* **Set** (представлено мапой, ключи которой будут являться элементами сет)
* **HashSet** - сохраняет элементы в бакетах используя механизм хеширования
* **LinkedHashSet** - сохраняет элементы в бакетах используя механизм хеширования,
  но при этом сохраняя порядок вставки элементов.
* **TreeSet** - сортированное хранение уникальных элементов, используется красночерное дерево
  для хранения, где ноды распределяются влево и вправо в зависимости от собственного порядка

* **Map** (отдельно потому что не итерируемые в привычном понимании коллекций)
* **HashMap** - классическая бакетная система ключей, хранение в паке ключ значение
* **LinkedHashMap** - классическая бакетная система ключей + сохранение порядка
* **HashTable** - потокобезопасная версия hashmap, работает так же
* **TreeMap** - работает как сет, храня ключи в красночерном дереве или самописном
  компараторе

</details>
<br>

<details>
    <summary>
        <b><big><big>
            В какой момент, какую использовать
         </big></big></b>
     </summary>

![](https://i.stack.imgur.com/aSDsG.png)

* **List**
* **ArrayList** - когда нужен быстрый поиск по индексу, но мы готовы потерпеть удаление вставку
* **LinkedList** - когда нужна быстрая вставка и удаление, но мы готовы терпеть поиск по индексу


* **Queue** (представлено связным списком) - когда важен порядок вложенности и выдачи
* **PriorityQueue** - когда нужен порядок зависимый от приоритета
* **ArrayDeque** - когда нужен порядок вставки выдачи, но при этом мы хотим получать
  как первый так и последний элемент


* **Set** - когда нужна уникальность
* **HashSet** - когда нужна уникальность и быстрота
* **LinkedHashSet** - когда нужна уникальность и сохранение порядка вставки
* **TreeSet** - когда нужна уникальность и фильтрация для оптимизации
  доступа, удаления, вставки, все работает как Log(n)


* **Map** - когда нужна пара ключ значение
* **HashMap** - когда нужна быстрота
* **LinkedHashMap** - когда нужен порядок вставки
* **HashTable** - когда нужна быстрота и потокобезопасность
* **TreeMap** - когда нужна сортировка по ключам

</details>
<br>

<details>
    <summary>
        <b><big><big>
            Concurrent коллекции
         </big></big></b>
     </summary>

Основные коллекции кроме HashTable являются непотокобезопастными, это значит
что, то есть, когда несколько параллельных потоков сохраняют и извлекают
элементы из этих коллекций, они могут повредить данные.

2 основных обеспечения синхронизированности

1. В пакете **Collections**
  * Collections.synchronizedList (List)
  * Collections.synchronizedSet (Set)
  * Collections.synchronizedMap (Map)

**Синхронизованность в этом случае обеспечивается внутренней блокировкой,
это значит что коллекция становится монитором, пускает в себя для записи только один
поток, но при этом сохраняется для чтения.**

2. В пакете **util.concurrent** (почти под каждый отдельный случай, но самые основные на мой взгляд)
  * ConcurrentHashMap
    **(точно так же хранит значения в бакетах, но монитор лочит только отдельный бакет
    на запись, не лоча остальные тем самым сохраняя потокобезопасность)**
  * CopyOnWriteArrayList
    **(операции получения значения применяются к оригинальной коллекции, когда операции
    модификации проводятся над копией существующего массива блокируя основную для модификации
    после результат перезаписывает основу, и следующая операция повторяет действие)**

</details>
<br>

</details>
<br>

[//]:# (Multithreading)

<details>
    <summary>
        <b><big><big><big>
            Multithreading
        </big></big></big></b>
    </summary>

<br>
<details>
    <summary>
        <b><big><big>
            Основные понятия
         </big></big></b>
     </summary>

**Потоки демоны** - потоки работающие в фоновом режиме которые завершаются в
автоматическом режиме при закрытии основного потока.

**Преимущества использования потоков? Что по минусам?**

Плюсы:

* скорость работы
* возможность оптимизации выполнения
* обработка большего числа запросов

Минусы:

* возможность блокировки потоков и истощения ресурсов

**Жизненный цикл потоков - NEW/RUNNABLE/BLOCKED/TIME_W/TERMINATED**

![](https://cdn-images-1.medium.com/max/533/1*UHoBS0lKLFI4gR8NgDENfw.png)

**Пути создания потока?**

* Наследуйте класс Thread и имплементируйте метод run()
* Интерфейс Runnable и имплементируйте метод run()
* Интерфейс Callable и имплементируйте метод call()

**Runnable and Callable интерфейсы**

Два функциональных интерфейса главное различие между которыми -
возвращаемое значение метода void run, <v> call

**Способы остановки потока**

* Ручной if-else (поток работает по условию)
* Метод interrupt (поток останавливается не сразу, а после выполнения
  текущего действия)
* Метод stop (но он деприкейтед, потому что сразу останавливает поток
  и может повлечь за собой проблемы)

**методы wait() sleep() notify() notifyAll()**

Методы взаимодействия с потоком определенные в классе Object

wait() заставляет поток ожидать, перевода его в статус BLOCKED, пока другой поток
не вызовет метод notify() или notifyAll(). Ожидание происходит на мониторе

**методы join() yield()**

yield() поток передает свое выполнение другому по приоритету
(полезно в ситуации когда у нас есть поток выполняющийся 5 часов и 2 потока которые
выполняются 3 минуты, чтобы не допустить 2м потоком ожидания мы пропускаем их вперед)

join() если есть цепь потоков и нам важно запустит поток ровно после завершения
выбранного

**thread pool**
Пулл потоков позволяет контролировать и переиспользовать потоки, позволяя,
контролировать число постоянно запущенных потоков.

**Разница между блокировкой на уровне объектов и классов**

* Блокировки на уровне объектов - когда вы хотите чтобы методы объекта были доступны только одному потоку
* Блокировки на уровне класса - когда мы хотим предотвратить вход нескольких потоков
  в синхронизированный блок во всех экземплярах класса

</details>
<br>

<details>
    <summary>
        <b><big><big>
            Happens before
         </big></big></b>
     </summary>

JVM может менять порядок выполнения инструкций для оптимизации собственной
работы. Если считает что эти инструкции не взаимосвязаны.
Но наша логика может на прямую зависеть от нашего выстроенного порядка,
поэтому было введено ключевое слово volatile которое заставляет записывать
и считывать переменную напрямую из heap а не из локальной памяти во избежание
грязного и фантомного чтения.

Но ухудшает перфоманс из-за того что кеш работает намного быстрее.

</details>
<br>

<details>
    <summary>
        <b><big><big>
            PESC в мультипоточности
         </big></big></b>
     </summary>

![](https://jenkov.com/images/java-concurrency/producer-consumer-2.png)

</details>
<br>

<details>
    <summary>
        <b><big><big>
            Locks/Atomics
         </big></big></b>
     </summary>

Большая часть коллекций и базовых операций по собственной сути не атомарна.
Они работают в несколько этапов, что создает проблемы грязного чтения в многопоточной
среде.

Для того чтобы решить эту проблему в мультипоточности были введены
с базовой стороны мониторы и волатайл.

Со стороны дополнительных библиотек появились Locks и Atomics

**Locks**

**ReentrantLock** - блокировка повторного входа. Механизм при котором избавляется
необходимость некоторых потоков ожидать пока другой поток завершит работу в блоке.
Мы пытаемся получить разрешение на вход в монитор не останавливая поток.

**ReadWriteLock** - позволяет в блоке кода явно выставлять запреты
на чтение или на запись.

**Atomics**

Предоставляет атомарные обвертки над обычными переменными, такие как
AtomicInteger, AtomicBoolean и т.д.

Они гарантируют что операция будет атомарной в один заход и не будет вызывать
проблем в многопоточной среде, и при этом предпочтительней волатайла по
тому что они оптимизированные под работу ЦП и работают быстрее.

</details>
<br>

<details>
    <summary>
        <b><big><big>
            Starvation / DeadLock / LiveLock
         </big></big></b>
     </summary>

**Livelock** — это тупиковая ситуация, в которой процессы
блокируют друг друга с повторяющимся изменением состояния,
но не продвигаются вперед.

**DeadLock** — это ситуация, когда процессы блокируют друг друга при
получении ресурсов и не продвигаются дальше.

**Starvation** — это результат процесса, который не может получить
доступ к общим ресурсам и, следовательно,
не может добиться какого-либо прогресса.

</details>
<br>

</details>
<br>

[//]:# (IO/NIO)

<details>
    <summary>
        <b><big><big><big>
            IO/NIO
        </big></big></big></b>
    </summary>

<br>
<details>
    <summary>
        <b><big><big>
            IO vs NIO разница
         </big></big></b>
     </summary>

* **Буфер** область для чтения фрагментов данных за раз
* **Канал** используется для связи с буфером
* **Селектор** предоставление доступа к каналам которые готовы к работе

**Java IO (Input/Output)** используется для выполнения операций чтения и записи.
Пакет java.io содержит все классы, необходимые для операций ввода и вывода.

* Однонаправленная работа с данными. Либо читать, либо писать
* Синхронная работа. Поток заходящий блокируется монитором
* На каждый буфер чтения и записи приходится один поток

**Java NIO (New IO)** был введен для реализации высокоскоростных операций ввода-вывода.

* Двунаправленная работа с потоком данных.
  Поскольку NIO работает при помощи буфера.
  Он единовременно может просить читать данные в буфер при этом выполняя другую работу
* Асинхронная работа. NIO не блокирует поток. Он может получить из буфера те данные
  которые есть на данный момент и пойти работать дальше
* Чтение в буфере может происходить в обе стороны, как назад так и вперед
* Поток получает возможность проверить завершено ли чтение, заполнен ли буферы
* Из-за того что у нас есть селекторы каналов, один поток может управлять сразу несколькими
  буферами

**Что когда использовать**

Зависит от поточности вашего приложения. 
NIO работают быстрее и не блокируют, но нам полностью нужно быть уверенными, 
что мы прочитаем все до конца.
IO блокирует поток и отпускает его когда чтение будет завершено

Разница между гибкостью и скоростью у NIO и гарантией работы IO

</details>
<br>

</details>
<br>

[//]:# (Serializations)

<details>
    <summary>
        <b><big><big><big>
            Serialization
        </big></big></big></b>
    </summary>

<br>
<details>
    <summary>
        <b><big><big>
         Способы сериализации объекта
        </big></big></b>
    </summary>

2 способа сериализации объекта

**Сериализация при помощи метода Serializable:**

- специфический маркерный интерфейс
- чтобы воспользоваться им мы должны вызвать у io стрима writeObject

**Сериализация при помощи метода Externalizable:**

- наследник маркерного интерфейса с двумя методами read/writeExternal
- позволяет нам создавать кастомную настройку сериализации и десериализации

</details>
<br>

<details>
    <summary>
        <b><big><big>
         Как ведут себя наследники и базовые классы при десериализации
        </big></big></b>
    </summary>

Когда класс реализует интерфейс java.io.Serializable,
все его подклассы также являются сериализуемыми.

И наоборот, когда объект имеет ссылку на другой объект,
эти объекты должны реализовывать интерфейс Serializable отдельно,
иначе будет выдано исключение NotSerializableException

</details>
<br>

</details>
<br>

[//]:# (Classloading)

<details>
    <summary>
        <b><big><big><big>
            Classloading
        </big></big></big></b>
    </summary>

<br>
<details>
    <summary>
        <b><big><big>
         Classloader и в каких ситуациях нам может быть полезно
        </big></big></b>
    </summary>

Загрузчики классов отвечают за **динамическую загрузку классов Java в JVM** 
во время выполнения.

Кроме того, эти классы Java загружаются в память не сразу, 
а тогда, когда они требуются приложению (LAZY).

* **Bootstrap** - загрузчик классов начальной загрузки
* **Extension** - обеспечивает загрузку расширений
* **System** - загружает все файлы переменной classpath

Модель делегирования - модель при которой загрузчики класса делегируют
поиск класса по цепочке вверх.

Однако в сценариях, когда нам нужно загружать классы с локального жесткого диска
или из сети, нам может потребоваться 
использовать пользовательские загрузчики классов.

* Помощь в изменении существующего байт-кода
* Создание классов, динамически подходящих для нужд пользователя 
(например переключение JDBC)

</details>
<br>

</details>
<br>

[//]:# (Garbage collector)

<details>
    <summary>
        <b><big><big><big>
            Garbage collector
        </big></big></big></b>
    </summary>

<br>
<details>
    <summary>
        <b><big><big>
         Какие бывают и какой когда использовать
        </big></big></b>
    </summary>

* Serial Garbage Collector
* Parallel Garbage Collector
* Concurrent Mark Sweep (CMS)
* Garbage First (G1)

**Serial** сборщик мусора хорошо подходит для однопоточных сред. 
Он использует единственный поток для сборки мусора. 
Он работает, удерживая все потоки приложения.
(Подходит для ситуации только с 1 ядром)

**Parallel** — это сборщик мусора по умолчанию, используемый JVM.
Работа параллельного сборщика мусора такая же, как у последовательного 
за исключением того что он работает в несколько потоков сборки.
(Подходит для стандартных ситуаций)

**CMS** - Он не замораживает потоки приложения во время сборки мусора.
Потоки GC выполняются одновременно с потоками приложения, но плата большее 
использование ЦП. 

**G1** - используется, если у нас большая (более 4 Гб) память (куча).
Он делит все на фрагменты. Но с фрагментацией есть проблемы, и из-за этого
ему требуется большая память.

</details>
<br>

</details>
<br>