<h1>Gang of Four Design Patterns</h1> 
<h4> 

[Back to menu](..%2FMenu.md)

</h4>

# Паттерны проектирования

## Что такое паттерны проектирования?

Паттернами проектирования (Design Patterns) 
называют решения часто встречающихся проблем в области разработки программного обеспечения. 

Идея паттернов была разработана Эрихом Гамму, 
Ричардом Хелму, Ральфом Джонсоном и Джоном Влиссидесом, их 
принято называть «бандой четырёх» (Gang of Four). 

## Плюсы паттернов

Самое главная причина — паттерны упрощают проектирование и поддержку программ

так же:
- **Проверенные решения**/**Стандартизация кода**
(паттерны помогают не изобретать велосипед, 
а использовать более или менее стандартизированные подходы)
- **Общий язык** 
Очень интересный вывод от стандартизации. 
Большая часть людей знает об этих подходах и не надо объяснять ничего 
лишнего при разговоре об постоении архитектуры

## Категории на которые деляться паттерны

Среди них выделяются следующие:

- **Порождающие паттерны** — описывают ситуации, процесс порождения классов и объектов. 
- **Структурные паттерны** - описывают ситуации соединения классов/методов/объектов 
в сложные структуры
- **Поведенческие паттерны** - описывает ситуации, алгоритмов и поведения между 

### Самые популярные паттерны

Порождающие:
- Фабрика
- Абстрактная фабрика
- Строитель
- Синглетон в остальных фреймворках

Структурные:
- Адаптера/Декоратора/Прокси
- Фасад

Поведенческие:
- Команда
- Стратегия/Состояние
- Итератор
- Наблюдатель

### Детально о паттернах группы "Порождающие"

#### Фабрика

**Основная идея** - Предоставить класс, который создаст объект абстрактного типа, 
и предоставит возможность выбора конкретной реализации.

**Основная реализация** - Предоставить общий интерфейс. 
И создать класс фабрику который будет создавать и возвращать конкретную реализацию интерфейса 
по определенному требованию.

![](https://refactoring.guru/images/patterns/content/factory-method/factory-method-ru.png)

**Проблема**

    Грузовые перевозки. 
    Сперва автомобили. Потом надо добавить лодочки.
    
    Но из-за того, что большая часть кода жёстко привязана к автомобилям. 
    Чтобы добавить в программу классы Лодочек, понадобится перелопатить всю программу. 
    В случае введения еще одного типа, будут еще больше проблем.
    
    Фабрика, предоставит нам объект транспорт,
    и мы будем работать с ним независимо от того, какой вид транспорта получили
    
![](https://refactoring.guru/images/patterns/diagrams/factory-method/problem1-en.png)    

**Когда следует использовать фабричный метод**

- Когда заранее неизвестно, объекты каких типов необходимо создавать
- Когда мы хотим дать возможность расширять сервис в будущем
- Когда создание новых объектов необходимо делегировать из базового класса классам наследникам

![atl-text](https://refactoring.guru/images/patterns/diagrams/factory-method/structure.png)

**Преимущества:**
- Гарантирует совместимость создаваемых объектов.
- Избавляет клиентский код от привязки к конкретным классам продуктов
- Выделяет код производства продуктов в одно место, упрощая поддержку кода
- Реализует принцип открытости/закрытости

**Недостатки:**
- Усложняет код программы из-за введения множества дополнительных классов.
- Требует наличия/учета всех типов продуктов в каждой вариации.
- Привязывание к определенному интерфейсу не всегда выгодно

#### Абстрактная Фабрика

**Основная идея** - Предоставить класс, который создаст сложный составной объект абстрактного типа, 
и предоставит возможность выбора конкретных реализаций.

**Основная реализация** - Самая простая реализация - Создать несколько фабрик. 
Создать класс фабрику который будет оперируя остальными фабриками создавать 
конкретную реализацию интерфейса по определенному требованию.

![](https://refactoring.guru/images/patterns/content/abstract-factory/abstract-factory-ru.png)

**Проблема**

    Мебельный магазин.
    У нас есть Кресло + Диван + Столик.
    В трёх разных стилях: Лофт, Классик, Хайтек.
    
    Вам необходимо создавать продуктов, в одинаковом стиле.  
    
    Но из-за того, что большая часть кода жёстко привязана к Одному из стилей. 
    Чтобы добавить в программу новый Тип, понадобится перелопатить всю программу. 
        
    На помощь приходит абстрактная фабрика которая, предоставит нам сложный объект,
    который будет гарантировано содержать товары одного типа
    
![](https://refactoring.guru/images/patterns/content/abstract-factory/abstract-factory-comic-1-ru.png)    

**Когда следует применять**
- Когда бизнес-логика программы должна работать с разными видами связанных 
друг с другом продуктов, не завися от конкретных классов продуктов.
- Когда в программе уже используется Фабричный метод, 
но очередные изменения предполагают введение новых типов продуктов.

![](https://refactoring.guru/images/patterns/diagrams/abstract-factory/example.png)

**Преимущества:**
- Гарантирует совместимость создаваемых объектов.
- Избавляет клиентский код от привязки к конкретным классам продуктов
- Выделяет код производства продуктов в одно место, упрощая поддержку кода
- Реализует принцип открытости/закрытости
- изолирует конкретные классы;
- упрощает замену семейств продуктов;

**Недостатки:**
- Усложняет код программы из-за введения множества дополнительных классов.
- Требует наличия/учета всех типов продуктов в каждой вариации.
- Сложно добавить поддержку нового вида продуктов, который параметрами разниться от общепринятого

#### Строитель

**Основная идея** - позволяет создавать сложные объекты пошагово.
Он предлагает вынести создание объекта и делегировать создание объекта другим классам.
Даст возможность использовать один и тот же код строительства для получения разных вариаций объектов.

**Основная реализация** - Самая простая реализация - 
public static final class builder который будет иметь методы наполнения полей объекта
и метод создания объекта после его наполнения.

![](https://refactoring.guru/images/patterns/content/builder/builder-ru.png)

**Проблема**

    Необходимо создать объект Дом. 
    Стандартно дом имеет крышу и стены.
    Но иногда мы хотим сад, бассейн и прочее
    
    Самое простое решение — расширить класс Дом, создав подклассы для всех комбинаций. 
    Но каждый новый параметр будет создавать все больше комбинаций подклассов
    
    Можно создать гигантский конструктор, но это будет вводить всех в ступор.
    
    Можно воспользоваться сетерами, но сетеры в частях программы могут неконтролируемо изменить объект
    без его ведома и иногда их может не быть (В ситуации когда кто-то не хочет чтобы объект не модился)
    
![](https://refactoring.guru/images/patterns/diagrams/builder/problem1.png)    

**Когда следует применять**
- Когда вы хотите избавиться от «Гигантского конструктора».
- Когда вам нужно собирать сложные составные объекты

![](https://refactoring.guru/images/patterns/diagrams/builder/example-ru.png)

**Преимущества:**
- Позволяет создавать продукты пошагово.
- Позволяет использовать один и тот же код для создания различных продуктов.
- Изолирует сложный код сборки продукта от его основной бизнес-логики.

**Недостатки:**
- Усложняет код программы из-за введения дополнительных классов.
- Клиент будет привязан к конкретным классам строителей, 
так как в интерфейсе строителя может не быть метода получения результата.

#### Прототип

**Основная идея** - дать возможность копирования объекта, вне зависимости от его реализации.

**Основная реализация** - Самая простая реализация - 
interface Cloneable / перегрузка Object.clone

![](https://refactoring.guru/images/patterns/content/prototype/prototype.png)

**Проблема**

    Нужно скопировать объект, в пустой объект этого же класса. 
    
    Но часть состояния объекта может быть приватной.
    
    Но есть и другая проблема. Копирующий код станет зависим от классов копируемых объектов. 
    Ведь, чтобы перебрать все поля объекта, нужно привязаться к его классу. 
    
![](https://refactoring.guru/images/patterns/content/prototype/prototype-comic-1-ru.png)

**Когда следует применять**
- Когда ваш код не должен зависеть от классов копируемых объектов.
- При наличии в системе большого количества однотипных подклассов 

![](https://refactoring.guru/images/patterns/diagrams/prototype/example.png)

**Преимущества:**
- Позволяет клонировать объекты, не привязываясь к их конкретным классам.
- Меньше повторяющегося кода инициализации объектов.
- Ускоряет создание объектов.
- Альтернатива созданию подклассов для конструирования сложных объектов.

**Недостатки:**
- Сложно клонировать составные объекты, имеющие ссылки на другие объекты.

**Реализация в Java**
Интерфейс Cloneable и его метод clone

#### Одиночка

**Основная идея** - гарантировать что у класса будет только один екземпляр 
и дать к нему глобальную точку доступа

**Основная реализация** - скрыть конструктор по умолчанию и создать публичный статический метод, 
который и будет возвращать объект-одиночку.

![](https://refactoring.guru/images/patterns/content/singleton/singleton.png)

**Проблема**

    Синглтон позволяет создать объект только при его необходимости. 
    Если объект не нужен, то он не будет создан. 
    В этом отличие синглтона от глобальных переменных.
    
![](https://refactoring.guru/images/patterns/content/singleton/singleton-comic-1-ru.png)

**Когда следует применять**
- Когда в программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам
- Когда вам хочется иметь больше контроля над глобальными переменными

![](https://refactoring.guru/images/patterns/diagrams/singleton/structure-ru.png)

**Преимущества:**
- Гарантирует наличие единственного экземпляра класса.
- Предоставляет к нему глобальную точку доступа.
- Реализует отложенную инициализацию объекта-одиночки.

**Недостатки:**
- Нарушает принцип единой ответственности 
(т.к. сразу совмещает в себе функции управления инстансом и назначения)
- Нарушает принцип открытости/закрытости 
(т.к. синглтон можно только изменить)
- Нарушает принцип подстановки Барбары Лисков
(т.к. заменить невозможно т.к. это уже не синглетон)
- Принцип разделения интерфейса:
(он его не нарушает просто потому что им не пользуется)
- Нарушает принцип инверсии зависимостей 
(т.к. есть только один конкретный инстанс)

- Очень сильно усложняет тестирование.
«Одиночка» привносит в программу глобальное состояние
поэтому, если тестировать какой-то класс, то мы обязаны вместе с ним тестировать и Singleton
Но синглетон может менять свое состояние из-за глобальности потому:
    - Вы не можете запускать несколько тестов параллельно;
    - Порядок тестов теперь имеет значение;
    - Тесты могут иметь нежелательные сторонние эффекты от его изменения.
    - Несколько вызовов одного и того же теста могут приводить к разным результатам

#### Детально о паттернах группы "Структурные"

##### Адаптер

**Основная идея** - позволяет объектам с несовместимыми интерфейсами работать вместе.

**Основная реализация** - создать сервис прослойку между двумя классами который будет 
конвертировать один тип в другой и наоборот.

![](https://refactoring.guru/images/patterns/content/adapter/adapter-en.png)

**Проблема**

    Приложение для торговли на бирже. 
    Приложение скачивает биржевые данные из нескольких источников в XML, 
    а затем рисует красивые графики.
    
    В какой-то момент нам необходимо улучшить приложение, 
    применив стороннюю библиотеку аналитики. 
    Но вот беда — библиотека поддерживает только формат данных JSON, 
    несовместимый с вашим приложением.
    
    Вы смогли бы переписать библиотеку, чтобы та поддерживала формат XML. 
    Но, во-первых, это может нарушить работу существующего кода, 
    который уже зависит от библиотеки. 
    А во-вторых, у вас может просто не быть доступа к её исходному коду.
    
    
![](https://refactoring.guru/images/patterns/diagrams/adapter/problem-en.png)

![](https://refactoring.guru/images/patterns/diagrams/adapter/solution-en.png)

**Когда следует применять**
- Когда вы хотите использовать сторонний класс, 
но его интерфейс не соответствует остальному коду приложения
-  Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то 
общей функциональности, причём расширить суперкласс вы не можете.

![](https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter.png)

![](https://refactoring.guru/images/patterns/diagrams/adapter/structure-class-adapter.png)

**Преимущества:**
- Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.

**Недостатки:**
- Усложняет код программы из-за введения дополнительных классов.

**Реализация в Java**
Arrays.asList() - мы можем кинуть туда массив а он вернет лист

##### Мост

**Основная идея** - разделяет один или несколько классов на 
абстракцию и реализацию, позволяя изменять их независимо друг от друга

**Основная реализация** - вынести всю меняющуюся абстракцию в интерфейс (цвет)
а реализацию в абстрактный класс с наследниками (фигура).

![](https://refactoring.guru/images/patterns/content/bridge/bridge.png)

**Проблема**

    Есть класс геометрических Фигур, который имеет подклассы Круг и Квадрат. 
    Вы хотите расширить иерархию фигур по цвету, то есть иметь Красные и Синие фигуры. 
    Но чтобы всё это объединить, вам придётся создать 4 комбинации подклассов, 
    вроде СиниеКруги и КрасныеКвадраты.
    
    При добавлении новых видов фигур и цветов количество комбинаций будет расти 
    в геометрической прогрессии. 
    Например, чтобы ввести в программу фигуры треугольников, 
    придётся создать сразу два новых подкласса треугольников под каждый цвет. 
    После этого новый цвет потребует создания уже трёх классов для всех видов фигур. 
    Чем дальше, тем хуже.
    
![](https://refactoring.guru/images/patterns/diagrams/bridge/problem-ru.png)

Решение

![](https://refactoring.guru/images/patterns/diagrams/bridge/solution-ru.png)

**Когда следует применять**
- Когда вы хотите разделить монолитный класс, который содержит несколько 
различных реализаций какой-то функциональности
- Когда класс нужно расширять в двух независимых плоскостях.
- Когда вы хотите, чтобы реализацию можно было бы изменять во время выполнения программы.

![](https://refactoring.guru/images/patterns/diagrams/bridge/structure-ru.png)

**Преимущества:**
- Позволяет строить платформо-независимые программы.
- Скрывает лишние или опасные детали реализации от клиентского кода.
- Реализует принцип открытости/закрытости.

**Недостатки:**
- Усложняет код программы из-за введения дополнительных классов.

##### Компоновщик

**Основная идея** - сгруппировать множество объектов в древовидную структуру, 
                    а затем работать с ней так, как будто это единичный объект.

**Основная реализация** - создать интерфейс, который будет описывать общее поведение компонентов.
Создать класс компоновщик который будет хранить в себе реализации интерфейса и других компоновщиков.

![](https://refactoring.guru/images/patterns/content/composite/composite.png)

**Проблема**

    есть два объекта: Продукт и Коробка. 
    Коробка может содержать несколько Продуктов и других Коробок. 
    Те, тоже содержат либо Продукты, либо Коробки и так далее.
    
    Продукты и Коробки могут быть частью заказов. 
    Каждый заказ может содержать как простые Продукты без упаковки, 
    так и составные Коробки. Задача состоит в том, чтобы узнать цену всего заказа.
    
    Если решать задачу в лоб, то вам потребуется открыть все коробки заказа, 
    перебрать все продукты и посчитать их суммарную стоимость. 
    Но это слишком хлопотно, так как типы коробок и их содержимое могут быть вам неизвестны. 
    Кроме того, наперёд неизвестно и количество уровней вложенности коробок, 
    поэтому перебрать коробки простым циклом не выйдет.
    
![](https://refactoring.guru/images/patterns/diagrams/composite/problem-ru.png)

Решение

![](https://refactoring.guru/images/patterns/content/composite/composite-comic-1-ru.png)

**Когда следует применять**
- Когда вам нужно представить древовидную структуру объектов.
- Когда клиенты должны единообразно трактовать простые и составные объекты.

![](https://refactoring.guru/images/patterns/diagrams/composite/structure-ru.png)

**Преимущества:**
- Упрощает архитектуру клиента при работе со сложным деревом компонентов.
- Облегчает добавление новых видов компонентов.

**Недостатки:**
- Создаёт слишком общий дизайн классов.
- Можно напороться на рекурсию

##### Декоратор

**Основная идея** - создание обверток над классом, для добавления нового функционала.

**Основная реализация** - базируется на принципе рекурсивного выполнения операции через серию связанных объектов.

![](https://refactoring.guru/images/patterns/content/decorator/decorator.png)

**Проблема**

    Вы работаете над библиотекой оповещений, ее можно подключать к разнообразным программам, 
    чтобы получать уведомления о важных событиях.
        
    Основой библиотеки является класс Notifier с методом send, 
    который принимает на вход строку-сообщение и высылает её всем администраторам 
    по электронной почте. 
    Сторонняя программа должна создать и настроить этот объект, 
    указав кому отправлять оповещения, а затем использовать его каждый раз, когда что-то случается.
    
    В какой-то момент стало понятно, что одних email-оповещений пользователям мало. 
    Некоторые из них хотели бы получать извещения о критических проблемах через SMS. 
    Другие хотели бы получать их в виде сообщений Facebook. 
    Корпоративные пользователи хотели бы видеть сообщения в OutLook.
    
    Сначала вы добавили каждый из этих типов оповещений в программу, 
    унаследовав их от базового класса Notifier. 
    Теперь пользователь выбирал один из типов оповещений, который и использовался в дальнейшем.
    
    Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу? 
    Ведь если вдруг в вашем доме начался пожар, вы бы хотели получить оповещения по всем каналам, 
    не так ли?
    
    Вы попытались реализовать все возможные комбинации подклассов оповещений. 
    Но после того как вы добавили первый десяток классов, стало ясно, 
    что такой подход невероятно раздувает код программы.
    
![](https://refactoring.guru/images/patterns/diagrams/decorator/problem3.png)

Решение

![](https://refactoring.guru/images/patterns/diagrams/decorator/solution1-ru.png)

**Когда следует применять**
- Когда вам нужно добавлять обязанности объектам на лету, 
незаметно для кода, который их использует
- Когда нельзя расширить обязанности объекта с помощью наследования.

![](https://refactoring.guru/images/patterns/diagrams/decorator/structure.png)

**Преимущества:**
- Большая гибкость, чем у наследования.
- Позволяет добавлять обязанности на лету.
- Можно добавлять несколько новых обязанностей сразу.
- Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.

**Недостатки:**
- Трудно конфигурировать многократно обёрнутые объекты.
- Обилие крошечных классов.

##### Фасад

**Основная идея** - предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

**Основная реализация** - Создаем класс пульт, который предоставляет несколько методов, 
а в них уже самостоятельно определяет как он, будет работать. 

![](https://refactoring.guru/images/patterns/content/facade/facade.png)

**Проблема**

    Вашему коду приходится работать с большим количеством объектов некой 
    сложной библиотеки или фреймворка. 
    Вы должны самостоятельно инициализировать эти объекты, 
    следить за правильным порядком зависимостей и так далее.
    
    В результате бизнес-логика ваших классов тесно переплетается с 
    деталями реализации сторонних классов. 
    Такой код довольно сложно понимать и поддерживать

Решение

![](https://refactoring.guru/images/patterns/diagrams/facade/live-example-ru.png)

**Когда следует применять**
- Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.
- Когда вы хотите разложить подсистему на отдельные слои.

![](https://refactoring.guru/images/patterns/diagrams/facade/structure.png)

**Преимущества:**
- Изолирует клиентов от компонентов сложной подсистемы.

**Недостатки:**
- Фасад рискует стать божественным объектом, привязанным ко всем классам программы.

**Реализация в Java**
Spring: DispatcherServlet принимает HTTP Req отдает HTTP Res
основная логика спрятана за этим простым фасадом

##### Легковес

**Основная идея** - позволяет вместить большое количество объектов в отведённую оперативную память

**Основная реализация** - разделяя неизменяемые и меняемые данные, 
                          и вместо хранения одинаковых данных в каждом объекте, 
                          хранится ссылка на повторяющиеся данные.

![](https://refactoring.guru/images/patterns/content/flyweight/flyweight.png)

**Проблема**

    Вы решили написать небольшую игру, в которой игроки перемещаются по карте 
    и стреляют друг в друга. 
    Фишкой игры должна была стать реалистичная система частиц. 
    Пули, снаряды, осколки от взрывов — всё это должно красиво летать и радовать взгляд.
    
    Игра отлично работала на вашем мощном компьютере. 
    Однако ваш друг сообщил, что игра начинает тормозить и вылетает через 
    несколько минут после запуска. 
    Покопавшись в логах, вы обнаружили, 
    что игра вылетает из-за недостатка оперативной памяти. 
    У вашего друга компьютер значительно менее «прокачанный», 
    поэтому проблема у него и проявляется так быстро.
    
    И действительно, каждая частица представлена собственным объектом, 
    имеющим множество данных. В определённый момент, 
    когда побоище на экране достигает кульминации, новые объекты 
    частиц уже не вмещаются в оперативную память компьютера, и программа вылетает.

**Решение**
Разбить сложный объект на части которые обязаны меняться (такие как положение)
и части которые не обязаны быть постоянно изменчивы.

И использовать кеш изменчивых объектов, чтобы в случае их повторения
доставать повторно объект из кеша и экономить на этом память

![](https://refactoring.guru/images/patterns/diagrams/flyweight/solution1-ru.png)

**Когда следует применять**
- Когда не хватает оперативной памяти для поддержки всех нужных объектов.

![](https://refactoring.guru/images/patterns/diagrams/flyweight/structure.png)

**Преимущества:**
- Экономит оперативную память.

**Недостатки:**
- Расходует процессорное время на поиск/вычисление контекста.
- Усложняет код программы из-за введения множества дополнительных классов.

##### Прокси

**Основная идея** - позволяет подставлять вместо реальных объектов специальные объекты-заменители. 

**Основная реализация** - Создание класса обвертки который перехватывает вызов к методам
оригинального объекта позволяя сделать что-то до или после оригинального вызова

![](https://refactoring.guru/images/patterns/content/proxy/proxy.png)

**Проблема**

    У вас есть платежная система.

    Платёжная карточка — это заместитель пачки наличных. 
    И карточка, и наличные имеют общий интерфейс — ими можно оплачивать товары. 
    Для покупателя польза в том, что не надо таскать с собой тонны наличных, 
    а владелец магазина рад, что ему не нужно делать дорогостоящую инкассацию 
    наличности в банк — деньги поступают к нему на счёт напрямую.
    
![](https://refactoring.guru/images/patterns/diagrams/proxy/solution-ru.png)    

**Решение**

![](https://refactoring.guru/images/patterns/diagrams/proxy/live-example.png)

**Когда следует применять**
- **Виртуальный прокси**
Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.
и вместо того, чтобы грузить данные сразу после старта программы, 
можно сэкономить ресурсы и создать объект тогда, когда он действительно понадобится.

- **Защищающий прокси** 
Когда в программе есть разные типы пользователей, 
и вам хочется защищать объект от неавторизованного доступа. 
( Прокси может проверять доступ при каждом вызове и передавать 
выполнение служебному объекту, если доступ разрешён.)

- **Удалённый прокси**
Когда настоящий сервисный объект находится на удалённом сервере.
Транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.

- **Логирующий прокси**  
Когда требуется хранить историю обращений к сервисному объекту.

- **Кеширующий прокси**
Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом.

![](https://refactoring.guru/images/patterns/diagrams/proxy/structure.png)

**Преимущества:**
- Позволяет контролировать сервисный объект незаметно для клиента.
- Может работать, даже если сервисный объект ещё не создан.
- Может контролировать жизненный цикл служебного объекта.

**Недостатки:**
- Усложняет код программы из-за введения дополнительных классов.
- Увеличивает время отклика от сервиса.

**В Java**
AOP
@transactional

#### Детально о паттернах группы "Поведенческие"

##### Цепочка обязанностей

**Основная идея** -  позволяет передавать запросы последовательно по цепочке обработчиков.
Каждый последующий обработчик решает, может ли он обработать запрос сам 
и стоит ли передавать запрос дальше по цепи.

**Основная реализация** - базируется на принципе рекурсивного выполнения операции через серию связанных объектов.
Но в отличие от декоратора, CofC сам определяет передавать ему действие дальше по цепи или остановиться.

![](https://refactoring.guru/images/patterns/content/chain-of-responsibility/chain-of-responsibility.png)

**Проблема**

    Система приёма онлайн-заказов. 
    Вы хотите чтобы только авторизованные пользователи могли создавать заказы. 
    
    Проверки нужно выполнять последовательно. 
    т.к. выполнять определенные проверки если какие-то свалились до этого не имеет смысла
    
    С каждой новой «фичей» код проверок, выглядящий как большой клубок 
    условных операторов, всё больше и больше раздувался. 
    
    Поддерживать такой код стало не только очень хлопотно, но и затратно. 
    И вот в один прекрасный день вы получаете задачу рефакторинга...
    
![](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/problem2-ru.png)

![](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/solution1-ru.png)

**Когда следует применять**
-  Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке.
-  Когда набор объектов, способных обработать запрос, должен задаваться динамически.

![](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/structure.png)

**Преимущества:**
- Уменьшает зависимость между клиентом и обработчиками.
- Реализует принцип единственной обязанности.
- Реализует принцип открытости/закрытости.

**Недостатки:**
- Запрос может остаться никем не обработанным.

#### Команда (Action)

**Основная идея** - превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов.
Это позволит нам ставить запросы в очередь, логировать и отменять в случае необходимости.

**Основная реализация** - Создать общий интерфейс для команд.
Создать сервис, который будет принимать имплементации интерфейса и пользоваться его методами.

![](https://refactoring.guru/images/patterns/diagrams/command/solution2-ru.png)

**Проблема**

    Текстового редактор. 
    Класс красивых кнопок вы хотите использовать для всех кнопок приложения.
    
    Но эти кнопки делают разные вещи. 
    Поэтому возникает вопрос: куда поместить код обработчиков кликов по этим кнопкам? 
    
    Некоторые операции, например, «сохранить», 
    можно вызывать из нескольких мест: нажав кнопку на панели управления,
    вызвав контекстное меню или просто нажав клавиши Ctrl+S. 
    Когда в программе были только кнопки, код сохранения имелся только в подклассе SaveButton. 
    Но теперь его придётся продублировать ещё в два класса.
    
![](https://refactoring.guru/images/patterns/diagrams/command/problem2.png)

![](https://refactoring.guru/images/patterns/diagrams/command/problem3-en.png)

**Решение**

![](https://refactoring.guru/images/patterns/diagrams/command/solution2-ru.png)

**Когда следует применять**
-  Когда вы хотите параметризовать объекты выполняемым действием.
-  Когда вы хотите ставить операции в очередь, выполнять их по расписанию или передавать по сети.
-  Когда вам нужна операция отмены.

![](https://refactoring.guru/images/patterns/diagrams/command/example.png)

**Преимущества:**
- Убирает прямую зависимость между объектами, вызывающими операции, 
и объектами, которые их непосредственно выполняют
- Позволяет реализовать простую отмену и повтор операций.
- Позволяет реализовать отложенный запуск операций.
- Позволяет собирать сложные команды из простых.
- Реализует принцип открытости/закрытости.

**Недостатки:**
- Усложняет код программы из-за введения множества дополнительных классов.

#### Итератор

**Основная идея** - даёт возможность последовательно обходить элементы составных объектов, 
                    не раскрывая их внутреннего представления.

**Основная реализация** - Самая простая реализация - iterable

![](https://refactoring.guru/images/patterns/content/iterator/iterator-en.png)

**Проблема**

    пользователь должен иметь возможность последовательно обходить элементы коллекции, 
    чтобы проделывать с ними какие-то действия.
    
    Но каким способом следует перемещаться по сложной структуре данных? 
    Например, сегодня может быть достаточным обход дерева в глубину, 
    но завтра потребуется возможность перемещаться по дереву в ширину. 
    А на следующей неделе и того хуже — понадобится обход коллекции в случайном порядке.
    
    Добавляя всё новые алгоритмы в код коллекции, вы понемногу размываете её основную задачу, 
    которая заключается в эффективном хранении данных. 
    Некоторые алгоритмы могут быть и вовсе слишком «заточены» под определённое приложение 
    и смотреться дико в общем классе коллекции.
    
![](https://refactoring.guru/images/patterns/diagrams/iterator/problem2.png)

**Решение**

![](https://refactoring.guru/images/patterns/diagrams/iterator/solution1.png)

**Аналог из жизни**

![](https://refactoring.guru/images/patterns/content/iterator/iterator-comic-1.png)

**Когда следует применять**
-  Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации 
-  Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.
-  Когда вам хочется иметь единый интерфейс обхода различных структур данных.

![](https://refactoring.guru/images/patterns/diagrams/iterator/structure.png)

**Преимущества:**
- Упрощает классы хранения данных
- Позволяет реализовать различные способы обхода структуры данных.
- Позволяет одновременно перемещаться по структуре данных в разные стороны.

**Недостатки:**
- Не оправдан, если можно обойтись простым циклом.

#### Медиатор

**Основная идея** - позволяет уменьшить связанность множества классов между собой, 
                    благодаря перемещению этих связей в один класс-посредник.

**Основная реализация** - Паттерн Посредник заставляет объекты общаться не напрямую друг с другом, 
а через отдельный объект-посредник, который знает, кому нужно перенаправить тот или иной запрос. 
Благодаря этому, компоненты системы будут зависеть только от посредника, а не от десятков других компонентов.

![](https://refactoring.guru/images/patterns/content/mediator/mediator.png)

**Проблема**

    У вас есть диалог создания профиля пользователя. 
    Он состоит из всевозможных элементов управления — текстовых полей, чекбоксов, кнопок.
    
    Отдельные элементы диалога должны взаимодействовать друг с другом. 
    Так, например, чекбокс «у меня есть собака» открывает скрытое поле 
    для ввода имени домашнего любимца, а клик по кнопке отправки запускает 
    проверку значений всех полей формы.
    
    Прописав эту логику прямо в коде элементов управления, 
    вы поставите крест на их повторном использовании в других местах приложения. 
    Они станут слишком тесно связанными с элементами диалога редактирования профиля, 
    которые не нужны в других контекстах. 
    Поэтому вы сможете использовать либо все элементы сразу, либо ни одного.
    
![](https://refactoring.guru/images/patterns/diagrams/mediator/problem1-en.png)

**Решение**

![](https://refactoring.guru/images/patterns/diagrams/mediator/solution1-en.png)

**Аналог из жизни**

![](https://refactoring.guru/images/patterns/diagrams/mediator/live-example.png)

**Когда следует применять**
-  Когда вам сложно менять некоторые классы из-за того, 
   что они имеют множество хаотичных связей с другими классами. 
-  Когда вы не можете повторно использовать класс, поскольку он зависит от уймы других классов.
-  Когда вам приходится создавать множество подклассов компонентов, 
   чтобы использовать одни и те же компоненты в разных контекстах.

![](https://refactoring.guru/images/patterns/diagrams/mediator/structure.png)

**Преимущества:**
- Устраняет зависимости между компонентами, позволяя повторно их использовать.
- Упрощает взаимодействие между компонентами.
- Централизует управление в одном месте.

**Недостатки:**
- Посредник может сильно раздуться.
- Посредник может стать божественным

#### Снимок (memento)

**Основная идея** - позволяет сохранять и восстанавливать прошлые состояния объектов, 
                    не раскрывая подробностей их реализации.

**Основная реализация** - Самая простая - Сериализация. 
Паттерн предлагает держать копию состояния в специальном объекте-снимке

![](https://refactoring.guru/images/patterns/content/memento/memento-ru.png)

**Проблема**

    Вы пишете программу текстового редактора. 
    Помимо обычного редактирования, ваш редактор позволяет менять форматирование текста, 
    вставлять картинки и прочее.
    
    В какой-то момент вы решили сделать все эти действия отменяемыми. 
    Для этого вам нужно сохранять текущее состояние редактора перед тем, 
    как выполнить любое действие. 
    Если потом пользователь решит отменить своё действие, 
    вы достанете копию состояния из истории и восстановите старое состояние редактора.
    
    Чтобы сделать копию состояния объекта, достаточно скопировать значение его полей. 
    Таким образом, если вы сделали класс редактора достаточно открытым, 
    то любой другой класс сможет заглянуть внутрь, чтобы скопировать его состояние.

    Казалось бы, что ещё нужно? 
    Ведь теперь любая операция сможет сделать резервную копию редактора перед своим действием. 
    Но такой наивный подход обеспечит вам уйму проблем в будущем. 
    Ведь если вы решите провести рефакторинг — 
    убрать или добавить парочку полей в класс редактора — 
    то придётся менять код всех классов, которые могли копировать состояние редактора.
    
    Но это ещё не все. Давайте теперь рассмотрим сами копии состояния редактора. 
    Из чего состоит состояние редактора? 
    Даже самый примитивный редактор должен иметь несколько полей для хранения текущего текста, 
    позиции курсора и прокрутки экрана. 
    Чтобы сделать копию состояния, вам нужно записать значения всех этих полей в некий «контейнер».
    
    Скорее всего, вам понадобится хранить массу таких контейнеров 
    в качестве истории операций, поэтому удобнее всего сделать их объектами одного класса. 
    Этот класс должен иметь много полей, но практически никаких методов. 
    Чтобы другие объекты могли записывать и читать из него данные, 
    вам придётся сделать его поля публичными. 
    Но это приведёт к той же проблеме, что и с открытым классом редактора. 
    Другие классы станут зависимыми от любых изменений в классе контейнера, 
    который подвержен тем же изменениям, что и класс редактора.
    
    Получается, нам придётся либо открыть классы для всех желающих, 
    испытывая массу хлопот с поддержкой кода, либо оставить классы закрытыми, 
    отказавшись от идеи отмены операций. Нет ли какого-то другого пути?    
    
![](https://refactoring.guru/images/patterns/diagrams/memento/problem1-ru.png)

**Когда следует применять**
-  Когда вам нужно сохранять мгновенные снимки состояния объекта (или его части), 
чтобы впоследствии объект можно было восстановить в том же состоянии.
-  Когда прямое получение состояния объекта раскрывает 
приватные детали его реализации, нарушая инкапсуляцию.

![](https://refactoring.guru/images/patterns/diagrams/memento/structure1.png)

**Преимущества:**
- Не нарушает инкапсуляции исходного объекта.
- Упрощает структуру исходного объекта. Ему не нужно хранить историю версий своего состояния.

**Недостатки:**
- Требует много памяти, если клиенты слишком часто создают снимки.
- Может повлечь дополнительные издержки памяти, если объекты, хранящие историю, 
не освобождают ресурсы, занятые устаревшими снимками.

**В Java реализован как:**
Все реализации java.io.Serializable 

#### Наблюдатель (observer)

**Основная идея** - создаёт механизм подписки, позволяющий одним объектам следить 
                    и реагировать на события, происходящие в других объектах. 
                    
**Основная реализация** - предлагает хранить внутри объекта издателя список ссылок 
на объекты подписчиков, причём подписчики сами должны добавляться/удаляться из издателя.

![](https://refactoring.guru/images/patterns/content/observer/observer.png)

**Проблема**

    Представьте, что вы имеете два объекта: Покупатель и Магазин. 
    В магазин вот-вот должны завезти новый товар, который интересен покупателю.
    
    Покупатель может каждый день ходить в магазин, 
    чтобы проверить наличие товара. 
    Но при этом он будет злиться, без толку тратя своё драгоценное время.
    
    С другой стороны, магазин может разослать спам каждому своему покупателю. 
    Многих это расстроит, так как товар специфический, и не всем он нужен.
    
    Получается конфликт: либо покупатель тратит время на периодические проверки, 
    либо магазин тратит ресурсы на бесполезные оповещения.   
    
![](https://refactoring.guru/images/patterns/content/observer/observer-comic-1.png)

**Решения**

![](https://refactoring.guru/images/patterns/diagrams/observer/solution1-ru.png)

**Когда следует применять**
-  Когда после изменения состояния одного объекта требуется что-то сделать в других,
но вы не знаете наперёд, какие именно объекты должны отреагировать.
-  Когда одни объекты должны наблюдать за другими, но только в определённых случаях.

![](https://refactoring.guru/images/patterns/diagrams/observer/structure.png)

**Преимущества:**
- Издатели не зависят от конкретных классов подписчиков и наоборот.
- Вы можете подписывать и отписывать получателей на лету.
- Реализует принцип открытости/закрытости.

**Недостатки:**
- Подписчики оповещаются в случайном порядке.

**В Java реализован как:**
Observable для Java
EventListener для swing
SessionAttributeListener для servlet

#### Состояние (state)

**Основная идея** - позволяет объектам менять поведение в зависимости от своего состояния.  
                    
**Основная реализация** - предлагает создать отдельные классы для каждого состояния, 
в котором может пребывать объект, 
а затем вынести туда поведения, соответствующие этим состояниям.

![](https://refactoring.guru/images/patterns/content/state/state-ru.png)

**Проблема**

    Документ может принимать три состояния: Черновик, Модерация или Опубликован. 
    В каждом из этих состояний метод опубликовать будет работать по-разному:
    
    Основная проблема такой машины состояний проявится в том случае, 
    если в Документ добавить ещё десяток состояний. 
    Каждый метод будет состоять из увесистого условного оператора, 
    перебирающего доступные состояния. 
    Такой код крайне сложно поддерживать. 
    Малейшее изменение логики переходов заставит вас перепроверять работу всех методов, 
    которые содержат условные операторы машины состояний.
    
    Путаница и нагромождение условий особенно сильно проявляется в старых проектах. 
    Набор возможных состояний бывает трудно предопределить заранее, 
    поэтому они всё время добавляются в процессе эволюции программы. 
    Из-за этого решение, которое выглядело простым и эффективным в самом начале разработки, 
    может впоследствии стать проекцией большого макаронного монстра.
    
![](https://refactoring.guru/images/patterns/diagrams/state/problem2-ru.png)

**Когда следует применять**
-  Когда у вас есть объект, поведение которого кардинально меняется в зависимости 
от внутреннего состояния, причём типов состояний много, и их код часто меняется.
-  Когда код класса содержит множество больших, похожих друг на друга, 
условных операторов, которые выбирают поведения в зависимости 
от текущих значений полей класса.
- Когда вы сознательно используете табличную машину состояний, 
построенную на условных операторах, но вынуждены мириться 
с дублированием кода для похожих состояний и переходов.

![](https://refactoring.guru/images/patterns/diagrams/state/structure-ru.png)

**Преимущества:**
- Избавляет от множества больших условных операторов машины состояний.
- Концентрирует в одном месте код, связанный с определённым состоянием.
- Упрощает код контекста.

**Недостатки:**
- Может неоправданно усложнить код, если состояний мало и они редко меняются.

**В Java реализован как:**
Observable для Java
EventListener для swing
SessionAttributeListener для servlet

#### Стратегия

**Основная идея** - создает классы стратегии которые будут вызываться в случае необходимости 
в изменении поведения базового объекта.  
                    
**Основная реализация** - предлагает создать отдельные классы для каждого состояния, 
в котором может пребывать объект, 
а затем вынести туда поведения, соответствующие этим состояниям.

![](https://refactoring.guru/images/patterns/content/strategy/strategy.png)

**Проблема**

    Вы решили написать приложение-навигатор для путешественников. 
    Оно должно показывать красивую и удобную карту, 
    позволяющую с лёгкостью ориентироваться в незнакомом городе.
    
    Одной из самых востребованных функций являлся поиск и прокладывание маршрутов. 
    Первая версия вашего навигатора могла прокладывать маршрут лишь по дорогам, 
    поэтому отлично подходила для путешествий на автомобиле. 
    Через некоторое время выяснилось, что некоторые люди предпочитают ездить 
    по городу на общественном транспорте. 
    Поэтому вы добавили и такую опцию прокладывания пути.
    
    Если с популярностью навигатора не было никаких проблем, 
    то техническая часть вызывала вопросы и периодическую головную боль. 
    С каждым новым алгоритмом код основного класса навигатора увеличивался вдвое. 
    В таком большом классе стало довольно трудно ориентироваться.
    
    Любое изменение алгоритмов поиска, будь то исправление багов 
    или добавление нового алгоритма, затрагивало основной класс. 
    Это повышало риск сделать ошибку, случайно задев остальной работающий код.
    
    Кроме того, осложнялась командная работа с другими программистами, 
    которых вы наняли после успешного релиза навигатора. 
    Ваши изменения нередко затрагивали один и тот же код, 
    создавая конфликты, которые требовали дополнительного времени на их разрешение.
    
![](https://refactoring.guru/images/patterns/diagrams/strategy/problem.png)

![](https://refactoring.guru/images/patterns/content/strategy/strategy-comic-1-en.png)

**Когда следует применять**
- Когда вам нужно использовать разные вариации какого-то алгоритма внутри одного объекта.
- Когда у вас есть множество похожих классов, отличающихся только некоторым поведением.
- Когда вы не хотите обнажать детали реализации алгоритмов для других классов.

![](https://refactoring.guru/images/patterns/diagrams/strategy/structure.png)

**Преимущества:**
- Горячая замена алгоритмов на лету.
- Изолирует код и данные алгоритмов от остальных классов.
- Уход от наследования к делегированию.
- Реализует принцип открытости/закрытости.

**Недостатки:**
- Усложняет программу за счёт дополнительных классов.
- Клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую.

**В Java реализован как:**
Пример можно найти в классе Http servlet с выбором стратегии 
(doGet, doPost, doPut, doDelete ...)

#### Шаблонный метод (Template)

**Основная идея** - определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы.  
Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры. 
                    
**Основная реализация** - предлагает разбить алгоритм на последовательность шагов, 
описать эти шаги в отдельных методах и вызывать их в одном шаблонном методе друг за другом.

![](https://refactoring.guru/images/patterns/content/template-method/template-method.png)

**Проблема**

    Вы пишете программу работы с офисными документами. 
    Пользователи будут загружать в неё документы в разных форматах (PDF, DOC, CSV), 
    а программа должна извлекать из них полезную информацию.
    
    В первой версии вы ограничились только обработкой DOC-файлов. 
    В следующей версии добавили поддержку CSV.
    А через месяц прикрутили работу с PDF-документами.
    
    В какой-то момент вы заметили, что код всех трёх классов обработки 
    документов хоть и отличается в части работы с файлами, 
    но содержат довольно много общего в части самого извлечения данных. 
    Было бы здорово избавится от повторной реализации алгоритма 
    извлечения данных в каждом из классов.
    
    К тому же остальной код, работающий с объектами этих классов, 
    наполнен условиями, проверяющими тип обработчика перед началом работы. 
    Весь этот код можно упростить, если слить все три класса воедино либо свести их к общему интерфейсу.
        
![](https://refactoring.guru/images/patterns/diagrams/template-method/problem.png)

![](https://refactoring.guru/images/patterns/diagrams/template-method/live-example.png)

**Когда следует применять**
- Когда подклассы должны расширять базовый алгоритм, не меняя его структуры.
- Когда у вас есть несколько классов, делающих одно и то же с незначительными отличиями. 
Если вы редактируете один класс, то приходится вносить такие же правки и в остальные классы.

![](https://refactoring.guru/images/patterns/diagrams/template-method/structure.png)

**Преимущества:**
- Облегчает повторное использование кода.

**Недостатки:**
- Вы жёстко ограничены скелетом существующего алгоритма.
- Вы можете нарушить принцип подстановки Барбары Лисков, 
изменяя базовое поведение одного из шагов алгоритма через подкласс.
- С ростом количества шагов шаблонный метод становится слишком сложно поддерживать.

**В Java реализован как:**
Классы пакета io 

#### Посетитель (Visitor)

**Основная идея** - позволяет добавлять в программу новые операции, 
                    не изменяя классы объектов, над которыми эти операции могут выполняться.
                    
**Основная реализация** - предлагает разместить новое поведение в отдельном классе, 
вместо того чтобы множить его сразу в нескольких классах. 
Объекты, с которыми должно было быть связано поведение, не будут выполнять его самостоятельно. 
Вместо этого вы будете передавать эти объекты в методы посетителя.

![](https://refactoring.guru/images/patterns/content/visitor/visitor.png)

**Проблема**

    Ваша команда разрабатывает приложение, работающее с геоданными. 
    Узлами являются городские локации: памятники, театры, рестораны, 
    важные предприятия и прочее. 
    Каждый узел имеет ссылки на другие, ближайшие к нему узлы. 
    Каждому типу узлов соответствует свой класс, а каждый узел представлен отдельным объектом.
    
    Ваша задача — сделать экспорт этих данных в XML. 
    Если бы мы могли редактировать классы объектов. 
    Достаточно было бы добавить метод экспорта в каждый класс, а затем, 
    перебирая объекты, вызывать этот метод. 
    Благодаря полиморфизму, решение получилось бы изящным, 
    так как вам не пришлось бы привязываться к конкретным классам.
    
    Но, к сожалению, классы узлов вам изменить не удалось. 
    Системный архитектор отказался вводить единый интерфейс и 
    придоставить остальным классам единый метод обработки.
    
    К тому же экспорт в XML вообще не уместен в рамках этих классов. 
    Их основная задача была связана с хранением данных  , 
    а экспорт выглядит в рамках этих классов чужеродно.
    
    Была и ещё одна причина запрета. Если на следующей неделе вам бы понадобился 
    экспорт в какой-то другой формат данных, то эти классы снова пришлось бы менять.
    
![](https://refactoring.guru/images/patterns/diagrams/visitor/problem2-ru.png)

**Когда следует применять**
- Когда подклассы должны расширять базовый алгоритм, не меняя его структуры.
- Когда у вас есть несколько классов, делающих одно и то же с незначительными отличиями. 
Если вы редактируете один класс, то приходится вносить такие же правки и в остальные классы.

![](https://refactoring.guru/images/patterns/diagrams/visitor/example.png)

**Преимущества:**
- Упрощает добавление операций, работающих со сложными структурами объектов.
- Объединяет родственные операции в одном классе.
- Посетитель может накапливать состояние при обходе структуры элементов.

**Недостатки:**
- Паттерн не оправдан, если иерархия элементов часто меняется.
- Может привести к нарушению инкапсуляции элементов.

---

## В чем отличия от Адаптера/Декоратора/Прокси

По сути дела они работают по одинаковой структуре.
Каким-то образом оборачивают искомый класс для того, 
чтобы вклиниться в его работу и каким-то образом взаимодействовать с ним.

**Адаптер** - класс прослойка между несовместимыми классами.
Она не изменяет оба класса, а является скорее перегонным кубом между ними.

**Прокси** - сам контролирует оборачиваемый класс.

**Декоратор** - клиент контролирует то, каким образом будут обвернуты классы между собой.

## В чем отличия от Стратегия/Состояние

В **состоянии** класс сам меняет поведение в зависимости от своего состояния.
(nextStep -> nextStep -> prevStep) 
В **стратегии** класс создает классы стратегии которые будут сетаться как поведение 
необходимому классу. Не строго предопределено.

# MVC

## Что такое MVC

Model-View-Controller — схема разделения данных приложения, 
пользовательского интерфейса и управляющей логики на три отдельных компонента: 
модель, представление и контроллер — таким образом, 
что модификация каждого компонента может осуществляться независимо.

Модель (Model) предоставляет данные и реагирует на команды контроллера, 
изменяя своё состояние.
Представление (View) отвечает за отображение данных модели пользователю, 
реагируя на изменения модели.
Контроллер (Controller) интерпретирует действия пользователя, 
оповещая модель о необходимости изменений.

![](https://metanit.com/sharp/aspnet5/pics/mvc.png)

# GRASP

## Что такое GRASP

GRASP (General Responsibility Assignment Software Patterns)
(Шаблоны программного обеспечения для распределения общей ответственности)
- 9 шаблонов: каждый помогает решить некоторую проблему, 
возникающую как в объектно-ориентированном проектировании, 
так и в практически любом проекте по разработке программного обеспечения.

## Информационный эксперт

**Определение** - Ответственность обработки данных должна быть назначена тому, 
кто владеет всей необходимой информации.

**Решает проблему**
Решает проблему спагетти-кода
Спагетти-код — плохо спроектированная, слабо структурированная, 
запутанная и трудная для понимания программа, 
особенно содержащая много операторов GOTO, 
исключений и других конструкций, ухудшающих структурированность. 
Самый распространённый антипаттерн программирования. 

Если какой-то класс получает все заказы клиентов (например в листе)
То он может содержать метод подсчета стоимости этих заказов

## Создатель (Creator)

**Определение** - Класс B должен нести ответственность за создание экземпляров класса A, 
если применимо одно или, предпочтительно, несколько из следующего:
- Содержать или агрегировать;
- Записывать;
- Использовать;
- Инициализировать, имея нужные данные.

**Решает проблему**
Определят ответственность за создание нового класса концентрируя ответственность 
к одному создателю.

## Контроллер (Controller)

**Определение** - это тот класс который
- Отвечает за операции которые приходят от пользователя, 
и может выполнять сценарии одного или нескольких вариантов использования
- Не выполняет работу самостоятельно, а делегирует другим классам  

**Решает проблему**
Определят ответственность за то кто должен обрабатывать системные события

## Слабое зацепление (Low Coupling)

**Определения**
«Степень зацепления» — мера зависимости элемента от других элементов
«Слабое» зацепление — обеспечивающее взаимную независимость классов.
т.е. это класс который:
    - Имеет слабую зависимость от других классов
    - Не зависит от внешних изменений
    - Прост для повторного использования
    
**Решает проблему**
Пытается обеспечить низкую зависимость, низкое влияние изменений и 
увеличение повторного использования    

## Высокая связность (High Cohesion)

**Определение** - ? - это класс который обладает следующими хар-ками:
    - Легкое восприятие;
    - Повторное использование;
    - Поддержка;
    - Устойчивость к внешним изменениям.

**Решает проблему**
Как сделать занятия целенаправленными, понятными и управляемыми

## Полиморфизм (Polymorphism)

**Определение** как и в ооп
Реализовывать одноименные публичные методы, 
позволяя различным классам выполнять различные действия при одном и том же вызове.

- Читаемость
- Расширяемость 

## Чистая выдумка (Pure Fabrication)

В случае если одной сущности в программе соответствуют 2 и более реализации.
То обязанности по взаимодействию между такими сущностями накладываются на них самих.
Это плохо потому что мы нарушаем принцип высокой связанности и низкой зацепленности.
Тут приходит чистая выдумка - это класс сервис который берет на себя работу по взаимодействию 
модулей между собой.

Такой паттерн:
    - Уменьшает зацепление;
    - Повышает связность;
    - Упрощает повторное использование.
    
в чем разница между Выдумкой и Посредником:
    Чистая выдумка описывает просто понятие сервиса
    Посредник - частный случай - является прослойкой между двумя классами убирая их зависимости

## Посредник (Indirection)

Как и GoF паттерн медитор - позволяет уменьшить связанность множества классов между собой, 
благодаря перемещению этих связей в один класс-посредник.

**Основная идея** - позволяет уменьшить связанность множества классов между собой, 
                    благодаря перемещению этих связей в один класс-посредник.

**Основная реализация** - Паттерн Посредник заставляет объекты общаться не напрямую друг с другом, 
а через отдельный объект-посредник, который знает, кому нужно перенаправить тот или иной запрос. 
Благодаря этому, компоненты системы будут зависеть только от посредника, а не от десятков других компонентов.

## Устойчивость к изменениям (Protected Variations)

Пытается решить проблему: Как спроектировать объекты, подсистемы и системы так, 
чтобы вариации или нестабильность этих элементов 
не оказывали нежелательного влияния на другие элементы?

Решение: Определите точки прогнозируемого изменения 
и распределите обязанности по созданию стабильного интерфейса вокруг них.

или использовать уже существующие решения

- Принципы SOLID, особенно принцип Open-Close (но все они поддерживают изменения)
- Шаблоны проектирования "Банда четырех" (GoF)
- Инкапсуляция
