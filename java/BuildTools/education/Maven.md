<h1>Maven</h1> 
<h4> 

[Back to menu](../Menu.md)

</h4>

[//]: # (Why is Maven considered bad at deploying artifacts?)
<br>
<details>
    <summary style="font-size: 25px;">
        <b>
            Why is Maven considered bad at deploying artifacts?
        </b>
    </summary>
<br>

While Maven is a powerful, established, and widely adopted tool 
for dependency management and build automation for Java projects, 
it might not always be the best fit for deploying artifacts.
Here are a few reasons why some developers find Maven lacking in this area:

1. Complexity: Maven's deployment process can be complex and difficult 
to customize, as changing the deployment process 
often involves understanding and modifying complex XML configuration files.

2. Inflexibility: Maven follows a rigid lifecycle model,
which might not be the best fit for every project. 
If your deployment needs fall outside 
the standard Maven lifecycle or require sophisticated customization, 
this can be problematic.

3. Speed: Deployment with Maven can be slower 
compared to some alternative tools because Maven runs 
through the entire lifecycle phases even 
when not all of them are necessary for deployment.

4. Verbose logging: Maven’s logging can be verbose, 
which might make it hard to debug deployment issues.

5. Lack of rollback functionality: 
Maven does not natively support rollback of deployment in case 
something goes wrong during the process. 
This might lead to additional manual efforts to fix it.

</details>

#### Деларативное против эмпиративного

Императивный стиль
Это такой стиль программирования, при котором вы описываете, как добиться желаемого результата. Например я пишу:
- поставь сковородку на огонь;
- возьми два яйца (куриных);
- нанеси удар ножом по каждому;
- вылей содержимое на сковородку;
- выкинь скорлупу;

Декларативный стиль
Такой стиль, в котором вы описываете, какой именно результат вам нужен.

Тут я просто пишу:
- приготовь яичницу

И получатель такого сообщения уже сам разбирается, какие шаги для этого надо предпринять.

### Что такое Maven? Как он работает?

Apache Maven - это фреймворк для автоматизации 
- сборки проектов 
- компиляции 
- выполнение тестов
- создания jar/war/pom/ejb/ear/rar/zip 
- создания дистрибутива программы 
- генерации документации. 

Зачем нужен?
Если собирать большие проекты с командной строки, 
то команда для сборки будет очень длинной, поэтому её иногда записывают в bat/sh скрипт. 
Но такие скрипты зависят от платформы. 
Для того чтобы избавиться от этой зависимостии и упростить написание скрипта 
используют инструменты для сборки проекта.

Maven, обеспечивает декларативную, а не императивную сборку проекта. 
То есть, в файлах проекта pom.xml содержится его декларативное описание, 
а не отдельные команды. Все задачи по обработке файлов Maven выполняется через плагины.

### Какие преимущества Maven?

- Независимость от OS. Сборка проекта происходит в любой операционной системе. Файл проекта один и тот же.

- Управление зависимостями. Редко какие проекты пишутся без использования сторонних библиотек(зависимостей). 
Эти сторонние библиотеки зачастую тоже в свою очередь используют библиотеки разных версий. 
Maven позволяет управлять такими сложными зависимостями. 
Что позволяет разрешать конфликты версий и в случае необходимости легко переходить на новые версии библиотек.

- Возможна сборка из командной строки. Такое часто необходимо для автоматической сборки проекта на сервере

- Хорошая интеграция со средами разработки. 
Основные среды разработки на java легко открывают проекты которые собираются c помощью maven. 
При этом зачастую проект настраивать не нужно - он сразу готов к дальнейшей разработке. 

- Как следствие - если с проектом работают в разных средах разработки, то maven удобный способ хранения настроек. 
Настроечный файл среды разработки и для сборки один и тот же - меньше дублирования данных и соответственно ошибок.

- Декларативное описание проекта.

- В мавен появились архитипы проектов, которые помогают стандартизировать исходные проекты.

### Какие недостатки Maven?

- Неочевидность. Если в Ant указывается команда на удаление - и удаляется файл, 
то в случае Maven надо всем сердцем довериться плагину и документации по нему.

- При таком объёме необходимых знаний документации не так много, 
особенно по каким-то специальным моментам. Да и просто читать придётся много. 
Порог вхождения, если потребуется собирать даже не самое сложное приложение куда выше, чем у Ant.

- Если нужно найти какой-то специальный плагин - это будет сделать непросто, 
плагинов много. И не факт, что найденный подойдёт на все 100% и будет работать без ошибок.

- Нужен доступ в интернет (или придётся разворачивать собственный репозиторий, что трудоёмко)

### Maven vs Gradle 

**Используемый язык для описания​**
- XML – Maven​
- DSL - Gradle

**Поддержка средами разработки​**
- Maven – хорошая​
- Gradle – читай доки

**Репозиторий для зависимостей​**
- Maven – mavenCentral​
- Gradle - mavenCentral

**Написание плагинов​**
- Maven – Java​
- Gradle – Java, Kotlin, Groovy

**Скорость сборки​**
- Maven – нормальная скорость​
- Gradle – быстрая + доп оптимизация

**Управление жизненным циклом​**
- Maven – жестко указаный​
- Gradle – собирай как хочешь

**Управление транзистивными зависимостями​**
- Maven – что задано пользователем​
- Gradle – выбрайте любой алгоритм

**Лаконичность описания сборки​**
- Maven – большой pom.xml​
- Gradle – build.gradle

**Вывод**
- Если нет надобности в дополнительном функционале​ выбери то, что  лучше знаешь.​
- Важна скорость сборки - gradle​
- Важна поддержка сред разработки - maven​
- Необходимо писать плагины - gradle
- Нужен специфический жизненный цикл - gradle

### Что такое артефакт в Maven?

Артефакт (artefact) - это, по сути, любая библиотека, хранящаяся в репозитории (месте хранения).
Это может быть какая-то зависимость или плагин. 
Обычно артефактом является JAR-файл, который хранится в репозитории Maven. 
Каждый артефакт содержит group ID, artifact ID и версию.

### Что такое задача в Maven?

Задача (goal) - это специальная задача, которая относится к сборке проекта и его управлению. 
на может привязываться как к нескольким фазам, так и ни к одной.
Задача, которая не привязана ни к одной фазе, может быть запущена вне фаз сборки с помощью прямого вызова.

### Какие типы репозитория существуют в Maven?

Локальный (local) репозиторий - это директория, которая хранится на нашем компьютере. 
Она создаётся в момент первого выполнения любой команды Maven. 
По умолчанию она расположена в <home директория>/.m2/repository - персональная для каждого пользователя.

Центральный (central) репозиторий - это репозиториий, который обеспечивается сообществом Maven. 
Он содержит огромное количество часто используемых библиотек. 
Который расположен в http://repo1.maven.org/maven2/ и доступен на чтение 
для всех пользователей в интернете. Если Maven не может найти зависимости в локальном репозитории, 
то автоматически начинается поиск необходимых файлов в центральном репозитории

Удалённые (remote) репозиторий - иногда, Maven не может 
найти необходимые зависимости в центральном репозитории. 
В этом случае, процесс сборки прерывается и в консоль выводится сообщение об ошибке. 
Для того, чтобы предотвратить подобную ситуацию, 
в Maven предусмотрен механизм Удалённого репозитория, который является репозиторием, 
который определяется самим разработчиком. Там могут храниться все необходимые зависимости.

### Назовите основные фазы жизненного цикла сборки Maven?

Когда Maven начинает сборку проекта, он проходит через определённую последовательность фаз сборки,
и выполняет определенные задачи, которые указаны в каждой из фаз.
 
##### В Maven есть следующие 3 стандартных жизненных цикла:
- Очистка (clean) - очищает артефакты, созданные до сборки.
- Сборка (default or build) - используется для создания приложения.
- Создание сайта проекта (site) - генерирует документацию сайта для проекта.

##### Clean очищает всю target папку проекта оставшующя после предыдущей сборки проекта
состоит из этапов 
- pre-clean
- clean 
- post-clean

##### Сборка состоит из 23 шагов:
- validate  - проверяет корректность метаинформации о проекте, подтверждает, является ли проект
- initialize - инициализирует состояние сборки, например, различные настройки.
- generate-sources - включает любой исходный код в фазу компиляции.
- process-resources - копирует и отправляет ресурсы в указанную директори. Это фаза перед упаковкой.
- compile - комплирует исходный код проекта.
- process-classes - обработка файлов, полученных в результате компляции. Например, оптимизация байт-кода Java классов.
- generate-test-sources - генерирует любые тестовые ресурсы, которые должны быть включены в фазу компиляции.
- process-test-sources - обрабатывает исходный код тестов. Например, фильтрует значения.
- test-compile - компилирует исходный код тестов в указанную директорию тестов.
- process-test-classes - обрабатывает файлы, полученные в результате компиляции исходного кода тестов.
- test - запускает тесты классов, используя приемлемый фреймворк юнит-тестирования (например, Junit).
- prepare-package - выполняет все необходимые операции для подготовки пакета, непосредственно перед упаковкой.
- package - преобразует скомпилированный код и пакет в дистрибутивный формат. Такие как JAR, WAR или EAR.
- pre-integration-test - выполняет необходимые действия перед выполнением интеграционных тестов.
- integration-test - обрабатывает и распаковывает пакет, если необходимо, в среду, где будут выполняться интеграционные тесты.
- post-integration-test - выполняет действия, необходимые  после выполнения интеграционных тестов. Например, освобождение ресурсов.
- verify - выполняет любые проверки для подтверждения того, что пакет пригоден и отвечает критериям качества.
- install - переносит пакет в локальный репозиторий, откуда он будет доступен для использования как зависимость в других проектах.
- deploy - копирует финальный пакет (архив) в удалённый репозиторий для, того, чтобы сделать его доступным другим разработчикам и проектам.

##### важно знать
- Когда мы выполняем команду Maven, например install, то будут выполенны фазы до install и фаза install.
- Различные задачи Maven будут привязаны к различным фазам жизненнго цикла Maven в зависимости от типа архива (JAR/WAR/EAR).

##### Site состоит из
- pre-site
- site
- post-site
- site-deploy

### Какие типы плагинов существуют в Maven?

- Плагины сборки (Build plugins) - выполняются в процессе сборки и должны быть 
конфигурированны внутри блока <build></build> файла pom.xml.
- Плагины отчётов (Reporting plugins) - выполняются в процесса генерирования сайта 
и должны быть конфигурированны внутри блока <reporting></reporting> файла pom.xml.
 
 
### Как Maven определяет какую версию зависимостей использовать когда встречается множественный вариант вибора?

Dependency mediation - определяет, какая версия зависимости будет использоваться, когда встречается
несколько версий артефактов, если две версии зависимости на той же глубине в дереве зависимостей,
то будет использоваться та которая объявлена первой. 
Здесь важен порядок объявления: первое объявление выигрывает.

### Что такое GAV секция в maven

Секция минимального описания pom файла мавен называется GAV секцией
GroupId
ArtifactId
Version

### Коротко об используемых тегах в pom
- project - описывает проект, это элемент верхнего уровня во всех файлах pom.xml.
- groupId - по-сути, это имя пакета. Полностью отражается в структуре каталогов.
- artifactId - название проекта. В структуре каталогов не отображается.
- version - версия проекта.
- packaging - определяет, какой тип файла будет собран. Варианты: pom, jar, war, ear.
- dependencies - указываются зависимости.
- build - информация о сборке проекта.
- name - это уже необязательные описания проекта. В данном случае его название.
- description - элемент представляет собой общее описание вашего проекта. 
Это часто используется в генерации документации Maven.
- url - интернет-страница проекта.
- repositories - репозитории для артефактов.
- pluginRepositories - репозитории для плагинов Maven.

### Профайлы в MAVEN

Мавен изначально создавался , принимая во внимание портируемость. 
Но довольно часто приложение приходится запускать в разном окружении: 
например, для разработки используется одна база данных, 
в рабочем сервере используется другая. 
при этом могут понадобиться разные настройки, разные зависимости и плагины. 
Для этих целей в maven используются профайлы.

Пример профайла: 

     <profile>
        <id>development</id>
        <properties>
            <database.url>jdbc:hsqldb:mem:testdb</database.url>
        </properties>
        <dependencies>
            <dependency>
                <groupId>org.hsqldb</groupId>
                <artifactId>hsqldb</artifactId>
                <version>2.0.0</version>
            </dependency>
        </dependencies>
    </profile>  
    
#### Активация профайла

Активировать профайл можно несколькими способами:
- во первых, это можно задать вручную в командной строке запуска maven, например: mvn package -P production
- Во вторых, при объявлении самого профайла можно задать тэг <activation>, который определяет какой профайл 
будет активирован: в нашем примере профайл development активный по умолчанию: 

        <settings>
          ...
          <profiles>
            <profile>
              <id>appserverConfig</id>
              <properties>
                <appserver.home>/path/to/appserver</appserver.home>
              </properties>
            </profile>
          </profiles>
    
          <activeProfiles>
            <activeProfile>appserverConfig</activeProfile>
          </activeProfiles>
          ...
        </settings>

Кроме активации по умолчанию можно задать активацию на основе операционной системы, 
установленных переменных окружения, версии JDK.

Данные которые профайл хранит в properties можно использовать в ресурсных файлах
для этого создается ресурсный файл db.url=${db.url} с пропертями
в билд прописывается 

        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
        
После сборки проперти активного профайла подставяться в значения в проверти файле и их можно использовать

#### Scope зависимостей мавен

Область действия scope определяет этап жизненного цикла проекта, в котором эта зависимость будет использоваться.

test
Если зависимость junit имеет область действия test, то эта зависимость будет использована maven'ом 
при выполнении компиляции той части проекта, которая содержит тесты, 
а также при запуске тестов на выполнение и построении отчета с результатами тестирования кода. 
Попытка сослаться на какой-либо класс или функцию библиотеки junit в основной части приложения 
(каталог src/main) вызовет ошибку.

compile
К наиболее часто используемой зависимости относится compile (используется по умолчанию). 
Т.е. dependency, помеченная как compile, или для которой не указано scope, будет доступна 
как для компиляции основного приложения и его тестов, 
так и на стадиях запуска основного приложения или тестов. 
Чтобы инициировать запуск тестов из управляемого maven-проекта можно выполнив команду "mvn test"
, а для запуска приложения используется плагин exec.

provided
Область действия зависимости provided аналогична compile, за исключением того, 
что артефакт используется на этапе компиляции и тестирования, а в сборку не включается. 
Предполагается, что среда исполнения (JDK или WEB-контейнер) предоставят данный артефакт 
во время выполнения программы. 
Наглядным примером подобных артефактов являются такие библиотеки, как hibernate или jsf, 
которые необходимы на этапе разработки приложения.

runtime
Область действия зависимости runtime не нужна для компиляции проекта и используется только на стадии 
выполнения приложения.

system
Область действия зависимости system аналогична provided за исключением того, 
что содержащий зависимость артефакт указывается явно в виде абсолютного пути к файлу, 
определенному в теге systemPath. 
Обычно к таким артефактам относятся собственные наработки, и искать их в центральном репозитории, 
куда Вы его не размещали, не имеет смысла :

    <scope>system</scope>
    <systemPath>
           d:/projects/libs/carousel-lib.jar
    </systemPath>
        
Все зависимости деляться на обычные и транзитивные

Прямые зависимости - это те, которые явно включены в проект. 
Они могут быть включены в проект с помощью тегов <dependency>:

С другой стороны, транзитивные зависимости - это зависимости, 
требуемые нашими прямыми зависимостями. 
Требуемые переходные зависимости автоматически включаются в наш проект Maven.        
        

### Не затронутые фичи Maven

 Use plugins for static code analyze (findbugs and/or pmd), check the code.
  Use checkstyle plugin, (you can take from
 http://checkstyle.sourceforge.net/google_style.html or any other)
 
 
### Многомодульный проект Maven

Мультимодульный проект построен из POM агрегатора, который управляет группой подмодулей. 
В большинстве случаев агрегатор находится в корневом каталоге проекта и должен иметь упаковку типа pom.
Теперь подмодули являются обычными проектами Maven, и их можно создавать отдельно или через POM-агрегатор.

Создавая проект через POM агрегатора, каждый проект с 
типом упаковки, отличным от pom, приведет к созданию файла архива.

**Существенным преимуществом использования этого подхода является то, что мы можем уменьшить дублирование.**

Поэтому, используя мультимодули, мы можем собрать модули нашего приложения в одну команду, и, 
если порядок имеет значение, Maven выяснит это для нас. Кроме того, мы можем поделиться огромным 
количеством конфигурации с другими модулями.

Структура проекта может содержать смежные и внутренние модули
Внутренные мавен модулю должны содержать parent структуру отсылающую к родительскому pom

    <modelVersion>4.0.0</modelVersion>
    <artifactId>InnerMavenModule2</artifactId>

    <parent>
        <artifactId>MavenProject</artifactId>
        <groupId>com.example</groupId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    
В родительском же pom файле указываются модулю учавствующие в сборке

    <modules>
        <module>InnerMavenModule</module>
        <module>InnerMavenModule2</module>
    </modules>
        
- Без модулей, главный не подхватит дочерние

- Без парента дочерний модуль может собраться главным если он указан в module

- Главный модуль имеет расширение pom 
(дочерние любое и из-за этого могут принципиально возникать исключения)
pom - это в основном контейнер подмодулей, каждый подмодуль представлен подкаталогом в том же каталоге, 
что и pom.xml с упаковкой pom.
При таком построении проекта, каждый подмодуль будет собираться независимо в каждом модуле
(если первый модуль собирает как war а второй как jar, 
после конца сборки в модуле war будет лежать war файл и jar в jar модуле соответственно)

- Сам проект с <packaging> pom не компилируется

- В случае если в дочерних присутствуют настройки которые присутствуют в родительском, 
используются настройки дочернего (Наследование)

- Чтобы скопировать полученные артифакты из субмодулей 

        <id>copy-artifact</id>
        <phase>package</phase>
        <goals>
            <goal>copy</goal>
        </goals>

https://mkyong.com/maven/maven-how-to-create-a-multi-module-project/
Достаточно интересный пример того как реализовано зависимое отношение между суб проектами

- В случае если в родительском будет указан еще один родитель, соберуться все его потомки

- Чтобы указать субмодуль на уровень ниже надо указать и верхний слой (InnerMavenModule/InheritorModule)

- При дублировании зависимости в корневом pom каталоге будет выдана ошибка

### pluginManagement и dependencyManager

pluginManagement позваляет писать плагины которые опциональны для перегрузки в дочерних класах
(Все что написано в <plagins></plagins> родительского, будет дублироваться в дочернем)

- Самое забавное что продительский пом который описывает у себя pluginManagement тоже обязан
перегружать этот плагин для использования

- В случае если метод из pluginManagement используется в <plagins></plagins> другого родителя
он будет использоваться и для его потомков

- **dependencyManager** Работает аналогичным образом. 
Предоставляет зависимость для наследования по желанию

### **версионирование** (Version Range References)

Версии любой зависимости в Maven можно вытаскивать динамически
для этого указыватся промежуток доступных версий
к примеру:
- [1.2,1.3]         1.2 <= x <= 1.3
- [1.0,2.0)         1.0 <= x < 2.0
- (,1.0],[1.2,)     x <= 1.0 or x >= 1.2.

Когда Maven встречает несколько совпадений для ссылки на версию, он использует версию с **наивысшим** соответствием. 
  
**Maven SNAPSHOT vs RELEASE**

Версия SNAPSHOT в Maven - это версия, которая еще не была выпущена.
Разница между «реальной» версией и версией снимка заключается в том, что снимки могут 
получать обновления. Это означает, что загрузка 1.0-SNAPSHOT сегодня может дать другой файл, 
чем загрузка вчера или завтра.

Это значит что когда мы скачиваем зависимость SNAPSHOT версии, мавен всегда будет скачивать версию этого
артефакта, поскольку мы можем не знать конкретно изменился он или нет. В отличии от обычной версии 1.0
которую мавен загружает единожды на свой локальный репозиторий и больше не трогает если не меняется версия

### Архетип Maven, собственные акхетипы

Архетип - Описательный шаблон проекта maven, который говорит нам по каким путям находятся те или иные файлы
в стандартном архетипе мавен исполняемые файлы лежат в 
   - Src->main->java
а тесты в
   - Src->test->java
   
1. Это помогает привести проект к одному типу
(не дает складывать тесты в классах и наоборот, повышает читаемость) 
2. Нужно понимать что стандартный архетип для мавен незыблим и любое отклонение от него 
(даже в названии папки java) будет караться пропуском в билде

### Собрать документацию с помощью мавен

1. Добавить в пом файл maven-javadoc-plugin

		<plugin>
			<groupId>org.apache.maven.plugins</groupId>
			<artifactId>maven-javadoc-plugin</artifactId>
			<executions>
				<execution>
					<id>attach-javadocs</id>
					<goals>
						<goal>jar</goal>
					</goals>
				</execution>
			</executions>
		</plugin>
		
2. прописать mvn install или просто собрать проект
3. в месте где будет собран проект появиться автоматически сгенерированаая документация